<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>nucml.ame.parsing_utilities API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nucml.ame.parsing_utilities</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># FINISHED 01/03/2020

import logging
import os
import sys
import numpy as np
import pandas as pd
import requests
import warnings

sys.path.append(&#34;..&#34;)
pd.options.mode.chained_assignment = None  # default=&#39;warn&#39;

from nucml.general_utilities import check_if_files_exist 
from nucml.processing import impute_values                   



def get_ame_originals(originals_directory):
    &#34;&#34;&#34;Requests and stores the three AME original files for further processing from the IAEA website.

    Args:
        originals_directory (str): path-like string where the text files will be stored.

    Returns:
        None
    &#34;&#34;&#34;    
    logging.info(&#34;AME: Requesting data text files.&#34;)
    # periodic_table = requests.get(&#39;https://raw.githubusercontent.com/pedrojrv/ML_Nuclear_Data/master/AME/Originals/periodic_table.csv&#39;).content
    mass16_txt = requests.get(&#39;https://www-nds.iaea.org/amdc/ame2016/mass16.txt&#39;).content
    rct1_txt = requests.get(&#39;https://www-nds.iaea.org/amdc/ame2016/rct1-16.txt&#39;).content
    rct2_txt = requests.get(&#39;https://www-nds.iaea.org/amdc/ame2016/rct2-16.txt&#39;).content

    logging.info(&#39;AME: Saving text files in provided directory.&#39;)
    # with open(os.path.join(originals_directory, &#39;periodic_table.csv&#39;), &#39;wb&#39;) as f:
    #     f.write(periodic_table)    
    with open(os.path.join(originals_directory, &#39;mass16.txt&#39;), &#39;wb&#39;) as f:
        f.write(mass16_txt)
    with open(os.path.join(originals_directory, &#39;rct1-16.txt&#39;), &#39;wb&#39;) as f:
        f.write(rct1_txt)
    with open(os.path.join(originals_directory, &#39;rct2-16.txt&#39;), &#39;wb&#39;) as f:
        f.write(rct2_txt)
    return None


def read_mass16(originals_directory, saving_directory):
    &#34;&#34;&#34;Reads the mass16.txt file and creates a formatted CSV file. The Mass 16 file contains a variety of 
    features including atomic mass, mass excess, binding energy, beta decay energy, and more.
    For more information visit the IAEA webiste: https://www-nds.iaea.org/amdc/
    
    It  is parse base on the Fortran formatting:
    a1,i3,i5,i5,i5,1x,a3,a4,1x,f13.5,f11.5,f11.3,f9.3,1x,a2,f11.3,f9.3,1x,i3,1x,f12.5,f11.5


    Args:
        originals_directory (str): path to the Atomic Mass Evaluation directory where the mass16_toparse.txt file is located.
        saving_directory (str): path to save resulting formatted csv file.

    Returns:
        None
    &#34;&#34;&#34;
    # Formating rules based on fortran formatting given by AME
    formatting = ((0,1),(1,5),(5,9),(9,14),(14,19),(19,20),(20,23),(23,27),(27,28),
               (28,41),(41,52),(52,63),(63,72),(72,73),(73,75),(75,86),(86,95),(95,96),
               (96,112),(112,123))

    # Column names as given by the AME documentation
    column_names = [&#34;Page_Feed&#34;, &#34;NZ&#34;, &#34;N&#34;, &#34;Z&#34;, &#34;A&#34;, &#34;Other&#34;, &#34;EL&#34;, &#34;O&#34;, &#34;Other2&#34;, \
           &#34;Mass_Excess&#34;, &#34;dMass_Excess&#34;, &#34;Binding_Energy&#34;, &#34;dBinding_Energy&#34;, &#34;Other3&#34;, \
           &#34;Beta_Type&#34;, &#34;B_Decay_Energy&#34;, &#34;dB_Decay_Energy&#34;, &#34;Other4&#34;,
           &#34;Atomic_Mass_Micro&#34;, &#34;dAtomic_Mass_Micro&#34;]


    filename = os.path.join(originals_directory, &#34;mass16.txt&#34;)
    logging.info(&#34;MASS16: Reading data from {}&#34;.format(filename))
    data = pd.read_fwf(filename, colspecs=formatting, header=None, skiprows=39, names=column_names)

    logging.info(&#34;MASS16: Beginning formatting sequences...&#34;)
    data[&#34;O&#34;].fillna(value=&#34;Other&#34;, inplace=True)
    data = data.replace(value=np.nan, to_replace=&#34;*&#34;)

    for col in data.select_dtypes(include=[&#39;object&#39;]):
        data[col] = data[col].apply(lambda x: str(x).replace(&#34;#&#34;, &#34;&#34;))

    mass16_dtypes = [&#39;float64&#39;, &#39;int64&#39;, &#39;int64&#39;, &#39;int64&#39;, &#39;int64&#39;, &#39;float64&#39;, &#39;object&#39;, &#39;object&#39;, &#39;float64&#39;, &#39;float64&#39;,
        &#39;float64&#39;, &#39;float64&#39;, &#39;float64&#39;, &#39;float64&#39;, &#39;object&#39;, &#39;object&#39;, &#39;float64&#39;, &#39;float64&#39;, &#39;object&#39;, &#39;float64&#39;]

    for col, types in zip(data.columns, mass16_dtypes):
        data[col] = data[col].astype(types)
        
    for col in [&#34;Atomic_Mass_Micro&#34;]:
        data[col] = data[col].astype(str)
        data[col] = data[col].str.strip(&#34;\&#34;&#34;)
        data[col] = data[col].str.replace(&#34; &#34;, &#34;&#34;)
        data[col] = data[col].str.strip()

    data[&#34;Atomic_Mass_Micro&#34;] = data[&#34;Atomic_Mass_Micro&#34;].astype(float)
    data[&#34;B_Decay_Energy&#34;] = data[&#34;B_Decay_Energy&#34;].astype(float)

    data.drop(columns=[&#34;Page_Feed&#34;, &#34;Other&#34;, &#34;Other2&#34;, &#34;Other3&#34;, &#34;Beta_Type&#34;, &#34;Other4&#34;, &#34;NZ&#34;], inplace=True)

    data[&#34;Element_w_A&#34;] = data[&#34;A&#34;].astype(str) + data[&#34;EL&#34;]

    csv_name = os.path.join(saving_directory, &#34;AME_mass16.csv&#34;)
    logging.info(&#34;MASS16: Formatting done. Saving file to {}&#34;.format(csv_name))
    data.to_csv(csv_name, index=False)
    logging.info(&#34;MASS16: Succesfully formated mass16.txt file.&#34;)
    return None

def read_rct1(originals_directory, saving_directory):
    &#34;&#34;&#34;Reads the rct1-16.txt file and creates a formatted CSV file. The rct1-16 file contains a variety of 
    features including neutron and proton separation energies and q-values for a variety of reactions.
    For more information visit the IAEA webiste: https://www-nds.iaea.org/amdc/
    
    It  is parse base on the Fortran formatting:
    a1,i3,1x,a3,i3,1x,6(f10.2,f8.2)

    Args:
        originals_directory (str): path to the Atomic Mass Evaluation directory where the rct1-16.txt file is located.
        saving_directory (str): path to save resulting formatted csv file.

    Returns:
        None
    &#34;&#34;&#34;
    formatting = ((0,1),(1,4),(4,5),(5,8),(8,11),(11,12),(12,22),(22,30),(30,40),
            (40,48),(48,58),(58,66),(66,76),(76,84),(84,94),(94,102),(102,112),(112,120))

    column_names = [&#34;Page_Feed&#34;, &#34;A&#34;, &#34;Other&#34;, &#34;EL&#34;, &#34;Z&#34;, &#34;Other2&#34;, &#34;S(2n)&#34;, &#34;dS(2n)&#34;, &#34;S(2p)&#34;, &#34;dS(2p)&#34;,
                &#34;Q(a)&#34;,  &#34;dQ(a)&#34;, &#34;Q(2B-)&#34;, &#34;dQ(2B-)&#34;, &#34;Q(ep)&#34;, &#34;dQ(ep)&#34;, &#34;Q(B-n)&#34;, &#34;dQ(B-n)&#34;]

    filename = os.path.join(originals_directory, &#34;rct1-16.txt&#34;)

    logging.info(&#34;RCT1: Reading data from {}&#34;.format(filename))
    data = pd.read_fwf(filename, colspecs=formatting, header=None, skiprows=39, names=column_names)
                    
    logging.info(&#34;RCT1: Beginning formatting sequences...&#34;)
    data = data.replace(to_replace=&#34;*&#34;, value=np.nan)
    data.drop(columns=[&#34;Other&#34;, &#34;Other2&#34;], inplace=True)

    for col in list(data.columns):
        data[col] = data[col].astype(str)
        data[col] = data[col].str.strip(&#34;\&#34;&#34;)
        data[col] = data[col].str.strip()
        data[col] = data[col].str.replace(&#34;#&#34;, &#34;.&#34;)

    for col in list(data.columns):
        if col == &#34;EL&#34;:
            pass
        else:
            data[col] = data[col].astype(float)

    data[[&#34;A&#34;, &#34;Z&#34;]] = data[[&#34;A&#34;, &#34;Z&#34;]].astype(int)
    data[&#34;N&#34;] = data[&#34;A&#34;] - data[&#34;Z&#34;]
    data[&#34;Element_w_A&#34;] = data[&#34;A&#34;].astype(str) + data[&#34;EL&#34;]
    data.drop(columns=[&#34;Page_Feed&#34;, &#34;A&#34;, &#34;EL&#34;, &#34;Z&#34;, &#34;N&#34;], inplace=True)

    csv_name = os.path.join(saving_directory, &#34;AME_rct1.csv&#34;)
    logging.info(&#34;RCT1: Formatting done. Saving file to {}&#34;.format(csv_name))
    data.to_csv(csv_name, index=False)
    logging.info(&#34;RCT1: Succesfully formated rct1-16.txt file.&#34;)
    return None

def read_rct2(originals_directory, saving_directory):
    &#34;&#34;&#34;Reads the rct2-16.txt file and creates a formatted CSV file. The rct2-16 file contains a variety of 
    features including neutron and proton separation energies and q-values for a variety of reactions.
    For more information visit the IAEA webiste: https://www-nds.iaea.org/amdc/

    It  is parse base on the Fortran formatting:
    a1,i3,1x,a3,i3,1x,6(f10.2,f8.2)

    Args:
        originals_directory (str): path to the Atomic Mass Evaluation directory where the rct2-16.txt file is located.
        saving_directory (str): path to save resulting formatted csv file.

    Returns:
        None
    &#34;&#34;&#34;
    formatting = ((0,1),(1,4),(4,5),(5,8),(8,11),(11,12),(12,22),(22,30),(30,40),
            (40,48),(48,58),(58,66),(66,76),(76,84),(84,94),(94,102),(102,112),(112,120))

    column_names = [&#34;Page_Feed&#34;, &#34;A&#34;, &#34;Other&#34;, &#34;EL&#34;, &#34;Z&#34;, &#34;Other2&#34;, &#34;S(n)&#34;, &#34;dS(n)&#34;, &#34;S(p)&#34;, &#34;dS(p)&#34;, &#34;Q(4B-)&#34;,
                &#34;dQ(4B-)&#34;, &#34;Q(d,a)&#34;, &#34;dQ(d,a)&#34;, &#34;Q(p,a)&#34;, &#34;dQ(p,a)&#34;, &#34;Q(n,a)&#34;, &#34;dQ(n,a)&#34;]

    filename = os.path.join(originals_directory, &#34;rct2-16.txt&#34;)


    logging.info(&#34;RCT2: Reading data from {}&#34;.format(filename))
    data = pd.read_fwf(filename, colspecs=formatting, header=None, skiprows=39, names=column_names)

    logging.info(&#34;RCT2: Beginning formatting sequences...&#34;)
    data = data.replace(to_replace=&#34;*&#34;, value=np.nan)
    data.drop(columns=[&#34;Other&#34;, &#34;Other2&#34;], inplace=True)

    for col in list(data.columns):
        data[col] = data[col].astype(str)
        data[col] = data[col].str.strip(&#34;\&#34;&#34;)
        data[col] = data[col].str.strip()
        data[col] = data[col].str.replace(&#34;#&#34;, &#34;.&#34;)

    for col in list(data.columns):
        if col == &#34;EL&#34;:
            pass
        else:
            data[col] = data[col].astype(float)


    data[[&#34;A&#34;, &#34;Z&#34;]] = data[[&#34;A&#34;, &#34;Z&#34;]].astype(int)
    data[&#34;N&#34;] = data[&#34;A&#34;] - data[&#34;Z&#34;]
    data[&#34;Element_w_A&#34;] = data[&#34;A&#34;].astype(str) + data[&#34;EL&#34;]
    data.drop(columns=[&#34;Page_Feed&#34;, &#34;A&#34;, &#34;EL&#34;, &#34;Z&#34;, &#34;N&#34;], inplace=True)

    csv_name = os.path.join(saving_directory, &#34;AME_rct2.csv&#34;)
    logging.info(&#34;RCT2: Formatting done. Saving file to {}&#34;.format(csv_name))
    data.to_csv(csv_name, index=False)
    logging.info(&#34;RCT2: Succesfully formated rct2-16.txt file.&#34;)
    return None

def merge_mass_rct(directory, create_imputed=True, add_qvalues=True):
    &#34;&#34;&#34;Reads the proccessed mass16, rct1, and rct2 files and merges them while adding other reaction 
    Q-values if needed. It creates one main CSV file when finished. This assumes the three files 
    were created using the read_mass(), read_rct1(), and read_rct2() functions. For more information 
    visit the IAEA webiste: https://www-nds.iaea.org/amdc/. It also creates a new CSV file where 
    missing values are filled via linear imputation paramenter- and element-wise.

    Args:
        directory (str): Path to the Atomic Mass Evaluation directory where 
            the processed mass16, rct2, and rct2 files are saved. The length of all three 
            files must be the same. The resulting file will be stored in the same directory.
        create_imputed (bool): If True, missing values will be imputed.
        add_qvalues (bool): If true it will add the following reaction Q-values:
            [&#34;Q(g,p)&#34;] = -1 * [&#34;S(p)&#34;]
            [&#34;Q(g,n)&#34;] = -1 * [&#34;S(n)&#34;]
            [&#34;Q(g,pn)&#34;] = [&#34;Q(d,a)&#34;] - 26071.0939
            [&#34;Q(g,d)&#34;] = [&#34;Q(d,a)&#34;] - 23846.5279
            [&#34;Q(g,t)&#34;] = [&#34;Q(p,a)&#34;] - 19813.8649
            [&#34;Q(g,He3)&#34;] = [&#34;Q(n,a)&#34;] - 20577.6194
            [&#34;Q(g,2p)&#34;] = -1 * [&#34;S(2p)&#34;]
            [&#34;Q(g,2n)&#34;] = -1 * [&#34;S(2n)&#34;]
            [&#34;Q(g,a)&#34;] = [&#34;Q(a)&#34;]
            [&#34;Q(p,n)&#34;] = [&#34;B_Decay_Energy&#34;] - 782.3465
            [&#34;Q(p,2p)&#34;] = -1 * [&#34;S(p)&#34;]
            [&#34;Q(p,pn)&#34;] = -1 * [&#34;S(n)&#34;]
            [&#34;Q(p,d)&#34;] = -1 * [&#34;S(n)&#34;] + 2224.5660
            [&#34;Q(p,2n)&#34;] = [&#34;Q(B-n)&#34;] - 782.3465
            [&#34;Q(p,t)&#34;] = -1 * [&#34;S(2n)&#34;] + 8481.7949
            [&#34;Q(p,3He)&#34;] = [&#34;Q(d,a)&#34;] - 18353.0535
            [&#34;Q(n,2p)&#34;] = [&#34;Q(ep)&#34;] + 782.3465
            [&#34;Q(n,np)&#34;] = -1 * [&#34;S(p)&#34;]
            [&#34;Q(n,d)&#34;] = -1 * [&#34;S(p)&#34;] + 2224.5660
            [&#34;Q(n,2n)&#34;] = -1 * [&#34;S(n)&#34;]
            [&#34;Q(n,t)&#34;] = [&#34;Q(d,a)&#34;] - 17589.2989
            [&#34;Q(n,3He)&#34;] = -1 * [&#34;S(2p)&#34;] + 7718.0404
            [&#34;Q(d,t)&#34;] = -1 * [&#34;S(n)&#34;] + 6257.2290
            [&#34;Q(d,3He)&#34;] = -1 * [&#34;S(p)&#34;] + 5493.4744
            [&#34;Q(3He,t)&#34;] = [&#34;B_Decay_Energy&#34;] - 18.5920
            [&#34;Q(3He,a)&#34;] = -1 * [&#34;S(n)&#34;] + 20577.6194
            [&#34;Q(t,a)&#34;] = -1 * [&#34;S(p)&#34;] + 19813.8649
    Returns:
        None
    &#34;&#34;&#34;
    saving_directory = directory
    logging.info(&#34;MERGE: Initializing. Checking documents...&#34;)
    mass16_path = os.path.join(directory, &#34;AME_mass16.csv&#34;)
    rct1_path = os.path.join(directory, &#34;AME_rct1.csv&#34;)
    rct2_path = os.path.join(directory, &#34;AME_rct2.csv&#34;)
    
    if check_if_files_exist([mass16_path, rct1_path, rct2_path]):
        logging.info(&#34;MERGE: Files exists. Reading data into dataframes...&#34;)
        data = pd.read_csv(mass16_path)
        rct1 = pd.read_csv(rct1_path)
        rct2 = pd.read_csv(rct2_path)
        
        df_final = pd.merge(data, rct1, on=&#39;Element_w_A&#39;)
        df_final = pd.merge(df_final, rct2, on=&#39;Element_w_A&#39;)

        if add_qvalues:
            logging.info(&#34;MERGE: Q-value Calculation: enabled. Calculating additional reaction energies...&#34;)
            df_final[&#34;Q(g,p)&#34;] = -1 * df_final[&#34;S(p)&#34;]
            df_final[&#34;Q(g,n)&#34;] = -1 * df_final[&#34;S(n)&#34;]
            df_final[&#34;Q(g,pn)&#34;] = df_final[&#34;Q(d,a)&#34;] - 26071.0939
            df_final[&#34;Q(g,d)&#34;] = df_final[&#34;Q(d,a)&#34;] - 23846.5279
            df_final[&#34;Q(g,t)&#34;] = df_final[&#34;Q(p,a)&#34;] - 19813.8649
            df_final[&#34;Q(g,He3)&#34;] = df_final[&#34;Q(n,a)&#34;] - 20577.6194
            df_final[&#34;Q(g,2p)&#34;] = -1 * df_final[&#34;S(2p)&#34;]
            df_final[&#34;Q(g,2n)&#34;] = -1 * df_final[&#34;S(2n)&#34;]
            df_final[&#34;Q(g,a)&#34;] = df_final[&#34;Q(a)&#34;]
            df_final[&#34;Q(p,n)&#34;] = df_final[&#34;B_Decay_Energy&#34;] - 782.3465
            df_final[&#34;Q(p,2p)&#34;] = -1 * df_final[&#34;S(p)&#34;]
            df_final[&#34;Q(p,pn)&#34;] = -1 * df_final[&#34;S(n)&#34;]
            df_final[&#34;Q(p,d)&#34;] = -1 * df_final[&#34;S(n)&#34;] + 2224.5660
            df_final[&#34;Q(p,2n)&#34;] = df_final[&#34;Q(B-n)&#34;] - 782.3465
            df_final[&#34;Q(p,t)&#34;] = -1 * df_final[&#34;S(2n)&#34;] + 8481.7949
            df_final[&#34;Q(p,3He)&#34;] = df_final[&#34;Q(d,a)&#34;] - 18353.0535
            df_final[&#34;Q(n,2p)&#34;] = df_final[&#34;Q(ep)&#34;] + 782.3465
            df_final[&#34;Q(n,np)&#34;] = -1 * df_final[&#34;S(p)&#34;]
            df_final[&#34;Q(n,d)&#34;] = -1 * df_final[&#34;S(p)&#34;] + 2224.5660
            df_final[&#34;Q(n,2n)&#34;] = -1 * df_final[&#34;S(n)&#34;]
            df_final[&#34;Q(n,t)&#34;] = df_final[&#34;Q(d,a)&#34;] - 17589.2989
            df_final[&#34;Q(n,3He)&#34;] = -1 * df_final[&#34;S(2p)&#34;] + 7718.0404
            df_final[&#34;Q(d,t)&#34;] = -1 * df_final[&#34;S(n)&#34;] + 6257.2290
            df_final[&#34;Q(d,3He)&#34;] = -1 * df_final[&#34;S(p)&#34;] + 5493.4744
            df_final[&#34;Q(3He,t)&#34;] = df_final[&#34;B_Decay_Energy&#34;] - 18.5920
            df_final[&#34;Q(3He,a)&#34;] = -1 * df_final[&#34;S(n)&#34;] + 20577.6194
            df_final[&#34;Q(t,a)&#34;] = -1 * df_final[&#34;S(p)&#34;] + 19813.8649

        csv_name = os.path.join(saving_directory, &#34;AME_all_merged.csv&#34;)
        logging.info(&#34;MERGE: Formatting done. Saving file to {}&#34;.format(csv_name))
        df_final.to_csv(csv_name, index=False)
        logging.info(&#34;MERGE: Succesfully merged files.&#34;)

        if impute_values:
            logging.info(&#34;MERGE: Imputing enabled. Interpolating...&#34;)
            csv_name = os.path.join(saving_directory, &#34;AME_all_merged_no_NaN.csv&#34;)
            
            warnings.filterwarnings(&#39;ignore&#39;)
            df_final = impute_values(df_final)
            df_final = df_final.interpolate(method=&#39;spline&#39;, order=1, limit=10, limit_direction=&#39;both&#39;)
            df_final = df_final.interpolate()
            warnings.filterwarnings(&#39;default&#39;)
            df_final.to_csv(csv_name, index=False)
            logging.info(&#34;MERGE: Succesfully merged files. Imputing missing values...&#34;)
 
    return None

def create_natural_element_data(originals_directory, saving_directory, fillna=True, mode=&#34;elemental&#34;, fill_value=0):
    &#34;&#34;&#34;Creates natural element data by averaging isotopic data. Additionally it
    adds a flag to indicate rows which correspond to isotopic or natural data.

    Args:
        originals_directory (str): path to the Atomic Mass Evaluation directory where the 
            periodic_table csv file is located.
        saving_directory (str): path to directory where the resulting formatted 
            csv file will be saved including the AME_all_merged.csv file.
        fillna (bool): if True, missing values are filled. For the remaining NaN values not filled by the
            used `mode`, a value of 0 will be inserted unless specified otherwise.
        mode (str): The supported modes are:
            elemental: missing values are filled using linear interpolation element-wise.
        fill_value (int, float): value to fill remaining missing values with after imputation is finished 
            with selected `mode`. Defaults to 0.
    Returns:
        None.
    &#34;&#34;&#34;
    directory = saving_directory
    logging.info(&#34;FEAT ENG: Initializing. Checking documents...&#34;)
    filename = os.path.join(directory, &#34;AME_all_merged.csv&#34;)
    periodic_filename = os.path.join(originals_directory, &#34;periodic_table.csv&#34;)
    if check_if_files_exist([filename, periodic_filename]):
        logging.info(&#34;FEAT ENG: Reading data from {}&#34;.format(filename))
        ame = pd.read_csv(filename)
        ame = ame.replace(to_replace=-0, value=0) # FORMATTING

        logging.info(&#34;FEAT ENG: Reading data from {}&#34;.format(periodic_filename))
        masses_natural = pd.read_csv(periodic_filename).rename(
            # Renaming columns for consistency with EXFOR:
            columns={&#39;NumberofNeutrons&#39;:&#39;Neutrons&#39;, &#39;NumberofProtons&#39;:&#39;Protons&#39;, 
            &#39;AtomicMass&#39;:&#39;Atomic_Mass_Micro&#39;, &#39;Symbol&#39;:&#39;EL&#39;})

        logging.info(&#34;FEAT ENG: Beginning data creation...&#34;)
        masses_natural[&#34;Mass_Number&#34;] = masses_natural[&#34;Neutrons&#34;] + masses_natural[&#34;Protons&#34;]
        # We don&#39;t need other columns in the periodic table csv file
        masses_natural = masses_natural[[&#34;Neutrons&#34;, &#34;Protons&#34;, &#34;Mass_Number&#34;, &#34;EL&#34;, &#34;Atomic_Mass_Micro&#34;]]

        # In EXFOR natural data is represented with a negative neutron value so we create this here:
        masses_natural[&#34;N&#34;] = masses_natural[&#34;Neutrons&#34;] * 0
        masses_natural[&#34;A&#34;] = masses_natural[&#34;Mass_Number&#34;] * 0
        masses_natural.columns = [&#34;N&#34;, &#34;Z&#34;, &#34;A&#34;, &#34;EL&#34;, &#34;Atomic_Mass_Micro&#34;, &#34;Neutrons&#34;, &#34;Mass_Number&#34;]
        masses_natural[&#34;Neutrons&#34;] = masses_natural[&#34;Mass_Number&#34;] - masses_natural[&#34;Z&#34;]

        # AME datasets deal with atomic mass in micro units:
        masses_natural[&#34;Atomic_Mass_Micro&#34;] = masses_natural[&#34;Atomic_Mass_Micro&#34;] * 1E6

        # We need to distinguish natural form isotopic. To accomplish this we introduce a flag:
        masses_natural[&#34;Flag&#34;] = &#34;N&#34;

        logging.info(&#34;FEAT ENG: Finished creating natural data. Merging with AME...&#34;)
        result = ame.append(masses_natural, sort=False)

        # Due to the merging process many NaN values are introduced. Here we fix this:
        result[&#34;Neutrons&#34;] = result.Neutrons.fillna(result.N).astype(int) # We first fill the Neutrons column with the N column values
        result[&#34;Mass_Number&#34;] = result.Mass_Number.fillna(result.A).astype(int) # same for Mass Number and A
        result.Flag.fillna(&#34;I&#34;, inplace=True) # We already have our natural tags we now that all NaNs are isotopic now.
        result[&#34;O&#34;].fillna(value=&#34;Other&#34;, inplace=True) # ASSUMPTION: We assume natural data was derive with Other 

        logging.info(&#34;FEAT ENG: Finishing up...&#34;)
        result = result.drop(columns=[&#34;Element_w_A&#34;]) # We don&#39;t need this 
        result = result.sort_values(by=&#34;Z&#34;) 
        
        csv_name = os.path.join(saving_directory, &#34;AME_Natural_Properties_w_NaN.csv&#34;)
        logging.info(&#34;FEAT ENG: Saving file to {}&#34;.format(csv_name))
        result.to_csv(csv_name, index=False)

        if fillna:
            warnings.filterwarnings(&#39;ignore&#39;)
            logging.info(&#34;FEAT ENG: Filling missing values using {} mode&#34;.format(mode.upper()))

            # The imputation methods change the column data data types, we save them
            # and transfer them after the imputation is perform.
            types = result.iloc[0:2]
            if mode.upper() == &#34;ELEMENTAL&#34;:
                # we fill the nans by taking the average of all isotopes, same for all other parameters.
                result = impute_values(result)
  
            logging.info(&#34;FEAT ENG: Filling remaining NaN values with 0...&#34;)
            result = result.fillna(fill_value)

            logging.info(&#34;FEAT ENG: Returning features to original data types...&#34;)
            for x in result.columns:
                result[x] = result[x].astype(types[x].dtypes.name)
            warnings.filterwarnings(&#39;default&#39;)


            csv_name = os.path.join(saving_directory, &#34;AME_Natural_Properties_no_NaN.csv&#34;)
            logging.info(&#34;FEAT ENG: Saving imputed file to {}&#34;.format(csv_name))
            result.to_csv(csv_name, index=False)
        
            logging.info(&#34;FEAT ENG: Sucessfully created natural data. Nan values were imputed.&#34;)
        else:
            logging.info(&#34;FEAT ENG: Succesfully created natural data. NaN values were not imputed.&#34;)
    else:
        logging.error(&#34;FEAT ENG: Merged file does not exists. Check your path and files.&#34;)
        sys.exit()
    return None

def get_all(originals_directory, saving_directory, fillna=True, fill_value=0, create_imputed=True, add_qvalues=True):
    &#34;&#34;&#34;Creates 5 CSV files: Proccesed (1) mass16, (2) rct1, and (3) rct2 files. It then creates
    a (4) single CSV merging the first three CSV files. It then creates (5) a proccesed CSV file
    containing isotpic and natural element data with NaN values. If wanted a (6) copy of the fifth
    CSV file is saved with imputed NaN values.

    Args:
        originals_directory (str): path to the Atomic Mass Evaluation directory where the 
            periodic_table csv file is located.
        saving_directory (str): path to directory where the resulting formatted 
            csv file will be saved.
        fillna (bool): if True it fills the missing values. For NaN values not filled by the
            used &#34;mode&#34;, then the filling method is just the mean of the entire dataset.
        fill_value (int, float): value to fill remaining missing values with after imputation is finished 
            with selected `mode`. Defaults to 0.
        create_imputed (bool): If True, missing values will be imputed.
        add_qvalues (bool): If true it will add the following reaction Q-values:
            [&#34;Q(g,p)&#34;] = -1 * [&#34;S(p)&#34;]
            [&#34;Q(g,n)&#34;] = -1 * [&#34;S(n)&#34;]
            [&#34;Q(g,pn)&#34;] = [&#34;Q(d,a)&#34;] - 26071.0939
            [&#34;Q(g,d)&#34;] = [&#34;Q(d,a)&#34;] - 23846.5279
            [&#34;Q(g,t)&#34;] = [&#34;Q(p,a)&#34;] - 19813.8649
            [&#34;Q(g,He3)&#34;] = [&#34;Q(n,a)&#34;] - 20577.6194
            [&#34;Q(g,2p)&#34;] = -1 * [&#34;S(2p)&#34;]
            [&#34;Q(g,2n)&#34;] = -1 * [&#34;S(2n)&#34;]
            [&#34;Q(g,a)&#34;] = [&#34;Q(a)&#34;]
            [&#34;Q(p,n)&#34;] = [&#34;B_Decay_Energy&#34;] - 782.3465
            [&#34;Q(p,2p)&#34;] = -1 * [&#34;S(p)&#34;]
            [&#34;Q(p,pn)&#34;] = -1 * [&#34;S(n)&#34;]
            [&#34;Q(p,d)&#34;] = -1 * [&#34;S(n)&#34;] + 2224.5660
            [&#34;Q(p,2n)&#34;] = [&#34;Q(B-n)&#34;] - 782.3465
            [&#34;Q(p,t)&#34;] = -1 * [&#34;S(2n)&#34;] + 8481.7949
            [&#34;Q(p,3He)&#34;] = [&#34;Q(d,a)&#34;] - 18353.0535
            [&#34;Q(n,2p)&#34;] = [&#34;Q(ep)&#34;] + 782.3465
            [&#34;Q(n,np)&#34;] = -1 * [&#34;S(p)&#34;]
            [&#34;Q(n,d)&#34;] = -1 * [&#34;S(p)&#34;] + 2224.5660
            [&#34;Q(n,2n)&#34;] = -1 * [&#34;S(n)&#34;]
            [&#34;Q(n,t)&#34;] = [&#34;Q(d,a)&#34;] - 17589.2989
            [&#34;Q(n,3He)&#34;] = -1 * [&#34;S(2p)&#34;] + 7718.0404
            [&#34;Q(d,t)&#34;] = -1 * [&#34;S(n)&#34;] + 6257.2290
            [&#34;Q(d,3He)&#34;] = -1 * [&#34;S(p)&#34;] + 5493.4744
            [&#34;Q(3He,t)&#34;] = [&#34;B_Decay_Energy&#34;] - 18.5920
            [&#34;Q(3He,a)&#34;] = -1 * [&#34;S(n)&#34;] + 20577.6194
            [&#34;Q(t,a)&#34;] = -1 * [&#34;S(p)&#34;] + 19813.8649
    Returns:
        None
    &#34;&#34;&#34;
    get_ame_originals(originals_directory)
    read_mass16(originals_directory, saving_directory)
    read_rct1(originals_directory, saving_directory)
    read_rct2(originals_directory, saving_directory)
    merge_mass_rct(saving_directory, add_qvalues=add_qvalues, create_imputed=create_imputed)
    create_natural_element_data(originals_directory, saving_directory, fillna=fillna, fill_value=fill_value)
    return None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="nucml.ame.parsing_utilities.create_natural_element_data"><code class="name flex">
<span>def <span class="ident">create_natural_element_data</span></span>(<span>originals_directory, saving_directory, fillna=True, mode='elemental', fill_value=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates natural element data by averaging isotopic data. Additionally it
adds a flag to indicate rows which correspond to isotopic or natural data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>originals_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to the Atomic Mass Evaluation directory where the
periodic_table csv file is located.</dd>
<dt><strong><code>saving_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to directory where the resulting formatted
csv file will be saved including the AME_all_merged.csv file.</dd>
<dt><strong><code>fillna</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, missing values are filled. For the remaining NaN values not filled by the
used <code>mode</code>, a value of 0 will be inserted unless specified otherwise.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The supported modes are:
elemental: missing values are filled using linear interpolation element-wise.</dd>
<dt><strong><code>fill_value</code></strong> :&ensp;<code>int, float</code></dt>
<dd>value to fill remaining missing values with after imputation is finished
with selected <code>mode</code>. Defaults to 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_natural_element_data(originals_directory, saving_directory, fillna=True, mode=&#34;elemental&#34;, fill_value=0):
    &#34;&#34;&#34;Creates natural element data by averaging isotopic data. Additionally it
    adds a flag to indicate rows which correspond to isotopic or natural data.

    Args:
        originals_directory (str): path to the Atomic Mass Evaluation directory where the 
            periodic_table csv file is located.
        saving_directory (str): path to directory where the resulting formatted 
            csv file will be saved including the AME_all_merged.csv file.
        fillna (bool): if True, missing values are filled. For the remaining NaN values not filled by the
            used `mode`, a value of 0 will be inserted unless specified otherwise.
        mode (str): The supported modes are:
            elemental: missing values are filled using linear interpolation element-wise.
        fill_value (int, float): value to fill remaining missing values with after imputation is finished 
            with selected `mode`. Defaults to 0.
    Returns:
        None.
    &#34;&#34;&#34;
    directory = saving_directory
    logging.info(&#34;FEAT ENG: Initializing. Checking documents...&#34;)
    filename = os.path.join(directory, &#34;AME_all_merged.csv&#34;)
    periodic_filename = os.path.join(originals_directory, &#34;periodic_table.csv&#34;)
    if check_if_files_exist([filename, periodic_filename]):
        logging.info(&#34;FEAT ENG: Reading data from {}&#34;.format(filename))
        ame = pd.read_csv(filename)
        ame = ame.replace(to_replace=-0, value=0) # FORMATTING

        logging.info(&#34;FEAT ENG: Reading data from {}&#34;.format(periodic_filename))
        masses_natural = pd.read_csv(periodic_filename).rename(
            # Renaming columns for consistency with EXFOR:
            columns={&#39;NumberofNeutrons&#39;:&#39;Neutrons&#39;, &#39;NumberofProtons&#39;:&#39;Protons&#39;, 
            &#39;AtomicMass&#39;:&#39;Atomic_Mass_Micro&#39;, &#39;Symbol&#39;:&#39;EL&#39;})

        logging.info(&#34;FEAT ENG: Beginning data creation...&#34;)
        masses_natural[&#34;Mass_Number&#34;] = masses_natural[&#34;Neutrons&#34;] + masses_natural[&#34;Protons&#34;]
        # We don&#39;t need other columns in the periodic table csv file
        masses_natural = masses_natural[[&#34;Neutrons&#34;, &#34;Protons&#34;, &#34;Mass_Number&#34;, &#34;EL&#34;, &#34;Atomic_Mass_Micro&#34;]]

        # In EXFOR natural data is represented with a negative neutron value so we create this here:
        masses_natural[&#34;N&#34;] = masses_natural[&#34;Neutrons&#34;] * 0
        masses_natural[&#34;A&#34;] = masses_natural[&#34;Mass_Number&#34;] * 0
        masses_natural.columns = [&#34;N&#34;, &#34;Z&#34;, &#34;A&#34;, &#34;EL&#34;, &#34;Atomic_Mass_Micro&#34;, &#34;Neutrons&#34;, &#34;Mass_Number&#34;]
        masses_natural[&#34;Neutrons&#34;] = masses_natural[&#34;Mass_Number&#34;] - masses_natural[&#34;Z&#34;]

        # AME datasets deal with atomic mass in micro units:
        masses_natural[&#34;Atomic_Mass_Micro&#34;] = masses_natural[&#34;Atomic_Mass_Micro&#34;] * 1E6

        # We need to distinguish natural form isotopic. To accomplish this we introduce a flag:
        masses_natural[&#34;Flag&#34;] = &#34;N&#34;

        logging.info(&#34;FEAT ENG: Finished creating natural data. Merging with AME...&#34;)
        result = ame.append(masses_natural, sort=False)

        # Due to the merging process many NaN values are introduced. Here we fix this:
        result[&#34;Neutrons&#34;] = result.Neutrons.fillna(result.N).astype(int) # We first fill the Neutrons column with the N column values
        result[&#34;Mass_Number&#34;] = result.Mass_Number.fillna(result.A).astype(int) # same for Mass Number and A
        result.Flag.fillna(&#34;I&#34;, inplace=True) # We already have our natural tags we now that all NaNs are isotopic now.
        result[&#34;O&#34;].fillna(value=&#34;Other&#34;, inplace=True) # ASSUMPTION: We assume natural data was derive with Other 

        logging.info(&#34;FEAT ENG: Finishing up...&#34;)
        result = result.drop(columns=[&#34;Element_w_A&#34;]) # We don&#39;t need this 
        result = result.sort_values(by=&#34;Z&#34;) 
        
        csv_name = os.path.join(saving_directory, &#34;AME_Natural_Properties_w_NaN.csv&#34;)
        logging.info(&#34;FEAT ENG: Saving file to {}&#34;.format(csv_name))
        result.to_csv(csv_name, index=False)

        if fillna:
            warnings.filterwarnings(&#39;ignore&#39;)
            logging.info(&#34;FEAT ENG: Filling missing values using {} mode&#34;.format(mode.upper()))

            # The imputation methods change the column data data types, we save them
            # and transfer them after the imputation is perform.
            types = result.iloc[0:2]
            if mode.upper() == &#34;ELEMENTAL&#34;:
                # we fill the nans by taking the average of all isotopes, same for all other parameters.
                result = impute_values(result)
  
            logging.info(&#34;FEAT ENG: Filling remaining NaN values with 0...&#34;)
            result = result.fillna(fill_value)

            logging.info(&#34;FEAT ENG: Returning features to original data types...&#34;)
            for x in result.columns:
                result[x] = result[x].astype(types[x].dtypes.name)
            warnings.filterwarnings(&#39;default&#39;)


            csv_name = os.path.join(saving_directory, &#34;AME_Natural_Properties_no_NaN.csv&#34;)
            logging.info(&#34;FEAT ENG: Saving imputed file to {}&#34;.format(csv_name))
            result.to_csv(csv_name, index=False)
        
            logging.info(&#34;FEAT ENG: Sucessfully created natural data. Nan values were imputed.&#34;)
        else:
            logging.info(&#34;FEAT ENG: Succesfully created natural data. NaN values were not imputed.&#34;)
    else:
        logging.error(&#34;FEAT ENG: Merged file does not exists. Check your path and files.&#34;)
        sys.exit()
    return None</code></pre>
</details>
</dd>
<dt id="nucml.ame.parsing_utilities.get_all"><code class="name flex">
<span>def <span class="ident">get_all</span></span>(<span>originals_directory, saving_directory, fillna=True, fill_value=0, create_imputed=True, add_qvalues=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates 5 CSV files: Proccesed (1) mass16, (2) rct1, and (3) rct2 files. It then creates
a (4) single CSV merging the first three CSV files. It then creates (5) a proccesed CSV file
containing isotpic and natural element data with NaN values. If wanted a (6) copy of the fifth
CSV file is saved with imputed NaN values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>originals_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to the Atomic Mass Evaluation directory where the
periodic_table csv file is located.</dd>
<dt><strong><code>saving_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to directory where the resulting formatted
csv file will be saved.</dd>
<dt><strong><code>fillna</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True it fills the missing values. For NaN values not filled by the
used "mode", then the filling method is just the mean of the entire dataset.</dd>
<dt><strong><code>fill_value</code></strong> :&ensp;<code>int, float</code></dt>
<dd>value to fill remaining missing values with after imputation is finished
with selected <code>mode</code>. Defaults to 0.</dd>
<dt><strong><code>create_imputed</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, missing values will be imputed.</dd>
<dt><strong><code>add_qvalues</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true it will add the following reaction Q-values:
["Q(g,p)"] = -1 * ["S(p)"]
["Q(g,n)"] = -1 * ["S(n)"]
["Q(g,pn)"] = ["Q(d,a)"] - 26071.0939
["Q(g,d)"] = ["Q(d,a)"] - 23846.5279
["Q(g,t)"] = ["Q(p,a)"] - 19813.8649
["Q(g,He3)"] = ["Q(n,a)"] - 20577.6194
["Q(g,2p)"] = -1 * ["S(2p)"]
["Q(g,2n)"] = -1 * ["S(2n)"]
["Q(g,a)"] = ["Q(a)"]
["Q(p,n)"] = ["B_Decay_Energy"] - 782.3465
["Q(p,2p)"] = -1 * ["S(p)"]
["Q(p,pn)"] = -1 * ["S(n)"]
["Q(p,d)"] = -1 * ["S(n)"] + 2224.5660
["Q(p,2n)"] = ["Q(B-n)"] - 782.3465
["Q(p,t)"] = -1 * ["S(2n)"] + 8481.7949
["Q(p,3He)"] = ["Q(d,a)"] - 18353.0535
["Q(n,2p)"] = ["Q(ep)"] + 782.3465
["Q(n,np)"] = -1 * ["S(p)"]
["Q(n,d)"] = -1 * ["S(p)"] + 2224.5660
["Q(n,2n)"] = -1 * ["S(n)"]
["Q(n,t)"] = ["Q(d,a)"] - 17589.2989
["Q(n,3He)"] = -1 * ["S(2p)"] + 7718.0404
["Q(d,t)"] = -1 * ["S(n)"] + 6257.2290
["Q(d,3He)"] = -1 * ["S(p)"] + 5493.4744
["Q(3He,t)"] = ["B_Decay_Energy"] - 18.5920
["Q(3He,a)"] = -1 * ["S(n)"] + 20577.6194
["Q(t,a)"] = -1 * ["S(p)"] + 19813.8649</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all(originals_directory, saving_directory, fillna=True, fill_value=0, create_imputed=True, add_qvalues=True):
    &#34;&#34;&#34;Creates 5 CSV files: Proccesed (1) mass16, (2) rct1, and (3) rct2 files. It then creates
    a (4) single CSV merging the first three CSV files. It then creates (5) a proccesed CSV file
    containing isotpic and natural element data with NaN values. If wanted a (6) copy of the fifth
    CSV file is saved with imputed NaN values.

    Args:
        originals_directory (str): path to the Atomic Mass Evaluation directory where the 
            periodic_table csv file is located.
        saving_directory (str): path to directory where the resulting formatted 
            csv file will be saved.
        fillna (bool): if True it fills the missing values. For NaN values not filled by the
            used &#34;mode&#34;, then the filling method is just the mean of the entire dataset.
        fill_value (int, float): value to fill remaining missing values with after imputation is finished 
            with selected `mode`. Defaults to 0.
        create_imputed (bool): If True, missing values will be imputed.
        add_qvalues (bool): If true it will add the following reaction Q-values:
            [&#34;Q(g,p)&#34;] = -1 * [&#34;S(p)&#34;]
            [&#34;Q(g,n)&#34;] = -1 * [&#34;S(n)&#34;]
            [&#34;Q(g,pn)&#34;] = [&#34;Q(d,a)&#34;] - 26071.0939
            [&#34;Q(g,d)&#34;] = [&#34;Q(d,a)&#34;] - 23846.5279
            [&#34;Q(g,t)&#34;] = [&#34;Q(p,a)&#34;] - 19813.8649
            [&#34;Q(g,He3)&#34;] = [&#34;Q(n,a)&#34;] - 20577.6194
            [&#34;Q(g,2p)&#34;] = -1 * [&#34;S(2p)&#34;]
            [&#34;Q(g,2n)&#34;] = -1 * [&#34;S(2n)&#34;]
            [&#34;Q(g,a)&#34;] = [&#34;Q(a)&#34;]
            [&#34;Q(p,n)&#34;] = [&#34;B_Decay_Energy&#34;] - 782.3465
            [&#34;Q(p,2p)&#34;] = -1 * [&#34;S(p)&#34;]
            [&#34;Q(p,pn)&#34;] = -1 * [&#34;S(n)&#34;]
            [&#34;Q(p,d)&#34;] = -1 * [&#34;S(n)&#34;] + 2224.5660
            [&#34;Q(p,2n)&#34;] = [&#34;Q(B-n)&#34;] - 782.3465
            [&#34;Q(p,t)&#34;] = -1 * [&#34;S(2n)&#34;] + 8481.7949
            [&#34;Q(p,3He)&#34;] = [&#34;Q(d,a)&#34;] - 18353.0535
            [&#34;Q(n,2p)&#34;] = [&#34;Q(ep)&#34;] + 782.3465
            [&#34;Q(n,np)&#34;] = -1 * [&#34;S(p)&#34;]
            [&#34;Q(n,d)&#34;] = -1 * [&#34;S(p)&#34;] + 2224.5660
            [&#34;Q(n,2n)&#34;] = -1 * [&#34;S(n)&#34;]
            [&#34;Q(n,t)&#34;] = [&#34;Q(d,a)&#34;] - 17589.2989
            [&#34;Q(n,3He)&#34;] = -1 * [&#34;S(2p)&#34;] + 7718.0404
            [&#34;Q(d,t)&#34;] = -1 * [&#34;S(n)&#34;] + 6257.2290
            [&#34;Q(d,3He)&#34;] = -1 * [&#34;S(p)&#34;] + 5493.4744
            [&#34;Q(3He,t)&#34;] = [&#34;B_Decay_Energy&#34;] - 18.5920
            [&#34;Q(3He,a)&#34;] = -1 * [&#34;S(n)&#34;] + 20577.6194
            [&#34;Q(t,a)&#34;] = -1 * [&#34;S(p)&#34;] + 19813.8649
    Returns:
        None
    &#34;&#34;&#34;
    get_ame_originals(originals_directory)
    read_mass16(originals_directory, saving_directory)
    read_rct1(originals_directory, saving_directory)
    read_rct2(originals_directory, saving_directory)
    merge_mass_rct(saving_directory, add_qvalues=add_qvalues, create_imputed=create_imputed)
    create_natural_element_data(originals_directory, saving_directory, fillna=fillna, fill_value=fill_value)
    return None</code></pre>
</details>
</dd>
<dt id="nucml.ame.parsing_utilities.get_ame_originals"><code class="name flex">
<span>def <span class="ident">get_ame_originals</span></span>(<span>originals_directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Requests and stores the three AME original files for further processing from the IAEA website.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>originals_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path-like string where the text files will be stored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ame_originals(originals_directory):
    &#34;&#34;&#34;Requests and stores the three AME original files for further processing from the IAEA website.

    Args:
        originals_directory (str): path-like string where the text files will be stored.

    Returns:
        None
    &#34;&#34;&#34;    
    logging.info(&#34;AME: Requesting data text files.&#34;)
    # periodic_table = requests.get(&#39;https://raw.githubusercontent.com/pedrojrv/ML_Nuclear_Data/master/AME/Originals/periodic_table.csv&#39;).content
    mass16_txt = requests.get(&#39;https://www-nds.iaea.org/amdc/ame2016/mass16.txt&#39;).content
    rct1_txt = requests.get(&#39;https://www-nds.iaea.org/amdc/ame2016/rct1-16.txt&#39;).content
    rct2_txt = requests.get(&#39;https://www-nds.iaea.org/amdc/ame2016/rct2-16.txt&#39;).content

    logging.info(&#39;AME: Saving text files in provided directory.&#39;)
    # with open(os.path.join(originals_directory, &#39;periodic_table.csv&#39;), &#39;wb&#39;) as f:
    #     f.write(periodic_table)    
    with open(os.path.join(originals_directory, &#39;mass16.txt&#39;), &#39;wb&#39;) as f:
        f.write(mass16_txt)
    with open(os.path.join(originals_directory, &#39;rct1-16.txt&#39;), &#39;wb&#39;) as f:
        f.write(rct1_txt)
    with open(os.path.join(originals_directory, &#39;rct2-16.txt&#39;), &#39;wb&#39;) as f:
        f.write(rct2_txt)
    return None</code></pre>
</details>
</dd>
<dt id="nucml.ame.parsing_utilities.merge_mass_rct"><code class="name flex">
<span>def <span class="ident">merge_mass_rct</span></span>(<span>directory, create_imputed=True, add_qvalues=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the proccessed mass16, rct1, and rct2 files and merges them while adding other reaction
Q-values if needed. It creates one main CSV file when finished. This assumes the three files
were created using the read_mass(), read_rct1(), and read_rct2() functions. For more information
visit the IAEA webiste: <a href="https://www-nds.iaea.org/amdc/.">https://www-nds.iaea.org/amdc/.</a> It also creates a new CSV file where
missing values are filled via linear imputation paramenter- and element-wise.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>directory</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the Atomic Mass Evaluation directory where
the processed mass16, rct2, and rct2 files are saved. The length of all three
files must be the same. The resulting file will be stored in the same directory.</dd>
<dt><strong><code>create_imputed</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, missing values will be imputed.</dd>
<dt><strong><code>add_qvalues</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true it will add the following reaction Q-values:
["Q(g,p)"] = -1 * ["S(p)"]
["Q(g,n)"] = -1 * ["S(n)"]
["Q(g,pn)"] = ["Q(d,a)"] - 26071.0939
["Q(g,d)"] = ["Q(d,a)"] - 23846.5279
["Q(g,t)"] = ["Q(p,a)"] - 19813.8649
["Q(g,He3)"] = ["Q(n,a)"] - 20577.6194
["Q(g,2p)"] = -1 * ["S(2p)"]
["Q(g,2n)"] = -1 * ["S(2n)"]
["Q(g,a)"] = ["Q(a)"]
["Q(p,n)"] = ["B_Decay_Energy"] - 782.3465
["Q(p,2p)"] = -1 * ["S(p)"]
["Q(p,pn)"] = -1 * ["S(n)"]
["Q(p,d)"] = -1 * ["S(n)"] + 2224.5660
["Q(p,2n)"] = ["Q(B-n)"] - 782.3465
["Q(p,t)"] = -1 * ["S(2n)"] + 8481.7949
["Q(p,3He)"] = ["Q(d,a)"] - 18353.0535
["Q(n,2p)"] = ["Q(ep)"] + 782.3465
["Q(n,np)"] = -1 * ["S(p)"]
["Q(n,d)"] = -1 * ["S(p)"] + 2224.5660
["Q(n,2n)"] = -1 * ["S(n)"]
["Q(n,t)"] = ["Q(d,a)"] - 17589.2989
["Q(n,3He)"] = -1 * ["S(2p)"] + 7718.0404
["Q(d,t)"] = -1 * ["S(n)"] + 6257.2290
["Q(d,3He)"] = -1 * ["S(p)"] + 5493.4744
["Q(3He,t)"] = ["B_Decay_Energy"] - 18.5920
["Q(3He,a)"] = -1 * ["S(n)"] + 20577.6194
["Q(t,a)"] = -1 * ["S(p)"] + 19813.8649</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_mass_rct(directory, create_imputed=True, add_qvalues=True):
    &#34;&#34;&#34;Reads the proccessed mass16, rct1, and rct2 files and merges them while adding other reaction 
    Q-values if needed. It creates one main CSV file when finished. This assumes the three files 
    were created using the read_mass(), read_rct1(), and read_rct2() functions. For more information 
    visit the IAEA webiste: https://www-nds.iaea.org/amdc/. It also creates a new CSV file where 
    missing values are filled via linear imputation paramenter- and element-wise.

    Args:
        directory (str): Path to the Atomic Mass Evaluation directory where 
            the processed mass16, rct2, and rct2 files are saved. The length of all three 
            files must be the same. The resulting file will be stored in the same directory.
        create_imputed (bool): If True, missing values will be imputed.
        add_qvalues (bool): If true it will add the following reaction Q-values:
            [&#34;Q(g,p)&#34;] = -1 * [&#34;S(p)&#34;]
            [&#34;Q(g,n)&#34;] = -1 * [&#34;S(n)&#34;]
            [&#34;Q(g,pn)&#34;] = [&#34;Q(d,a)&#34;] - 26071.0939
            [&#34;Q(g,d)&#34;] = [&#34;Q(d,a)&#34;] - 23846.5279
            [&#34;Q(g,t)&#34;] = [&#34;Q(p,a)&#34;] - 19813.8649
            [&#34;Q(g,He3)&#34;] = [&#34;Q(n,a)&#34;] - 20577.6194
            [&#34;Q(g,2p)&#34;] = -1 * [&#34;S(2p)&#34;]
            [&#34;Q(g,2n)&#34;] = -1 * [&#34;S(2n)&#34;]
            [&#34;Q(g,a)&#34;] = [&#34;Q(a)&#34;]
            [&#34;Q(p,n)&#34;] = [&#34;B_Decay_Energy&#34;] - 782.3465
            [&#34;Q(p,2p)&#34;] = -1 * [&#34;S(p)&#34;]
            [&#34;Q(p,pn)&#34;] = -1 * [&#34;S(n)&#34;]
            [&#34;Q(p,d)&#34;] = -1 * [&#34;S(n)&#34;] + 2224.5660
            [&#34;Q(p,2n)&#34;] = [&#34;Q(B-n)&#34;] - 782.3465
            [&#34;Q(p,t)&#34;] = -1 * [&#34;S(2n)&#34;] + 8481.7949
            [&#34;Q(p,3He)&#34;] = [&#34;Q(d,a)&#34;] - 18353.0535
            [&#34;Q(n,2p)&#34;] = [&#34;Q(ep)&#34;] + 782.3465
            [&#34;Q(n,np)&#34;] = -1 * [&#34;S(p)&#34;]
            [&#34;Q(n,d)&#34;] = -1 * [&#34;S(p)&#34;] + 2224.5660
            [&#34;Q(n,2n)&#34;] = -1 * [&#34;S(n)&#34;]
            [&#34;Q(n,t)&#34;] = [&#34;Q(d,a)&#34;] - 17589.2989
            [&#34;Q(n,3He)&#34;] = -1 * [&#34;S(2p)&#34;] + 7718.0404
            [&#34;Q(d,t)&#34;] = -1 * [&#34;S(n)&#34;] + 6257.2290
            [&#34;Q(d,3He)&#34;] = -1 * [&#34;S(p)&#34;] + 5493.4744
            [&#34;Q(3He,t)&#34;] = [&#34;B_Decay_Energy&#34;] - 18.5920
            [&#34;Q(3He,a)&#34;] = -1 * [&#34;S(n)&#34;] + 20577.6194
            [&#34;Q(t,a)&#34;] = -1 * [&#34;S(p)&#34;] + 19813.8649
    Returns:
        None
    &#34;&#34;&#34;
    saving_directory = directory
    logging.info(&#34;MERGE: Initializing. Checking documents...&#34;)
    mass16_path = os.path.join(directory, &#34;AME_mass16.csv&#34;)
    rct1_path = os.path.join(directory, &#34;AME_rct1.csv&#34;)
    rct2_path = os.path.join(directory, &#34;AME_rct2.csv&#34;)
    
    if check_if_files_exist([mass16_path, rct1_path, rct2_path]):
        logging.info(&#34;MERGE: Files exists. Reading data into dataframes...&#34;)
        data = pd.read_csv(mass16_path)
        rct1 = pd.read_csv(rct1_path)
        rct2 = pd.read_csv(rct2_path)
        
        df_final = pd.merge(data, rct1, on=&#39;Element_w_A&#39;)
        df_final = pd.merge(df_final, rct2, on=&#39;Element_w_A&#39;)

        if add_qvalues:
            logging.info(&#34;MERGE: Q-value Calculation: enabled. Calculating additional reaction energies...&#34;)
            df_final[&#34;Q(g,p)&#34;] = -1 * df_final[&#34;S(p)&#34;]
            df_final[&#34;Q(g,n)&#34;] = -1 * df_final[&#34;S(n)&#34;]
            df_final[&#34;Q(g,pn)&#34;] = df_final[&#34;Q(d,a)&#34;] - 26071.0939
            df_final[&#34;Q(g,d)&#34;] = df_final[&#34;Q(d,a)&#34;] - 23846.5279
            df_final[&#34;Q(g,t)&#34;] = df_final[&#34;Q(p,a)&#34;] - 19813.8649
            df_final[&#34;Q(g,He3)&#34;] = df_final[&#34;Q(n,a)&#34;] - 20577.6194
            df_final[&#34;Q(g,2p)&#34;] = -1 * df_final[&#34;S(2p)&#34;]
            df_final[&#34;Q(g,2n)&#34;] = -1 * df_final[&#34;S(2n)&#34;]
            df_final[&#34;Q(g,a)&#34;] = df_final[&#34;Q(a)&#34;]
            df_final[&#34;Q(p,n)&#34;] = df_final[&#34;B_Decay_Energy&#34;] - 782.3465
            df_final[&#34;Q(p,2p)&#34;] = -1 * df_final[&#34;S(p)&#34;]
            df_final[&#34;Q(p,pn)&#34;] = -1 * df_final[&#34;S(n)&#34;]
            df_final[&#34;Q(p,d)&#34;] = -1 * df_final[&#34;S(n)&#34;] + 2224.5660
            df_final[&#34;Q(p,2n)&#34;] = df_final[&#34;Q(B-n)&#34;] - 782.3465
            df_final[&#34;Q(p,t)&#34;] = -1 * df_final[&#34;S(2n)&#34;] + 8481.7949
            df_final[&#34;Q(p,3He)&#34;] = df_final[&#34;Q(d,a)&#34;] - 18353.0535
            df_final[&#34;Q(n,2p)&#34;] = df_final[&#34;Q(ep)&#34;] + 782.3465
            df_final[&#34;Q(n,np)&#34;] = -1 * df_final[&#34;S(p)&#34;]
            df_final[&#34;Q(n,d)&#34;] = -1 * df_final[&#34;S(p)&#34;] + 2224.5660
            df_final[&#34;Q(n,2n)&#34;] = -1 * df_final[&#34;S(n)&#34;]
            df_final[&#34;Q(n,t)&#34;] = df_final[&#34;Q(d,a)&#34;] - 17589.2989
            df_final[&#34;Q(n,3He)&#34;] = -1 * df_final[&#34;S(2p)&#34;] + 7718.0404
            df_final[&#34;Q(d,t)&#34;] = -1 * df_final[&#34;S(n)&#34;] + 6257.2290
            df_final[&#34;Q(d,3He)&#34;] = -1 * df_final[&#34;S(p)&#34;] + 5493.4744
            df_final[&#34;Q(3He,t)&#34;] = df_final[&#34;B_Decay_Energy&#34;] - 18.5920
            df_final[&#34;Q(3He,a)&#34;] = -1 * df_final[&#34;S(n)&#34;] + 20577.6194
            df_final[&#34;Q(t,a)&#34;] = -1 * df_final[&#34;S(p)&#34;] + 19813.8649

        csv_name = os.path.join(saving_directory, &#34;AME_all_merged.csv&#34;)
        logging.info(&#34;MERGE: Formatting done. Saving file to {}&#34;.format(csv_name))
        df_final.to_csv(csv_name, index=False)
        logging.info(&#34;MERGE: Succesfully merged files.&#34;)

        if impute_values:
            logging.info(&#34;MERGE: Imputing enabled. Interpolating...&#34;)
            csv_name = os.path.join(saving_directory, &#34;AME_all_merged_no_NaN.csv&#34;)
            
            warnings.filterwarnings(&#39;ignore&#39;)
            df_final = impute_values(df_final)
            df_final = df_final.interpolate(method=&#39;spline&#39;, order=1, limit=10, limit_direction=&#39;both&#39;)
            df_final = df_final.interpolate()
            warnings.filterwarnings(&#39;default&#39;)
            df_final.to_csv(csv_name, index=False)
            logging.info(&#34;MERGE: Succesfully merged files. Imputing missing values...&#34;)
 
    return None</code></pre>
</details>
</dd>
<dt id="nucml.ame.parsing_utilities.read_mass16"><code class="name flex">
<span>def <span class="ident">read_mass16</span></span>(<span>originals_directory, saving_directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the mass16.txt file and creates a formatted CSV file. The Mass 16 file contains a variety of
features including atomic mass, mass excess, binding energy, beta decay energy, and more.
For more information visit the IAEA webiste: <a href="https://www-nds.iaea.org/amdc/">https://www-nds.iaea.org/amdc/</a></p>
<p>It
is parse base on the Fortran formatting:
a1,i3,i5,i5,i5,1x,a3,a4,1x,f13.5,f11.5,f11.3,f9.3,1x,a2,f11.3,f9.3,1x,i3,1x,f12.5,f11.5</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>originals_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to the Atomic Mass Evaluation directory where the mass16_toparse.txt file is located.</dd>
<dt><strong><code>saving_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to save resulting formatted csv file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_mass16(originals_directory, saving_directory):
    &#34;&#34;&#34;Reads the mass16.txt file and creates a formatted CSV file. The Mass 16 file contains a variety of 
    features including atomic mass, mass excess, binding energy, beta decay energy, and more.
    For more information visit the IAEA webiste: https://www-nds.iaea.org/amdc/
    
    It  is parse base on the Fortran formatting:
    a1,i3,i5,i5,i5,1x,a3,a4,1x,f13.5,f11.5,f11.3,f9.3,1x,a2,f11.3,f9.3,1x,i3,1x,f12.5,f11.5


    Args:
        originals_directory (str): path to the Atomic Mass Evaluation directory where the mass16_toparse.txt file is located.
        saving_directory (str): path to save resulting formatted csv file.

    Returns:
        None
    &#34;&#34;&#34;
    # Formating rules based on fortran formatting given by AME
    formatting = ((0,1),(1,5),(5,9),(9,14),(14,19),(19,20),(20,23),(23,27),(27,28),
               (28,41),(41,52),(52,63),(63,72),(72,73),(73,75),(75,86),(86,95),(95,96),
               (96,112),(112,123))

    # Column names as given by the AME documentation
    column_names = [&#34;Page_Feed&#34;, &#34;NZ&#34;, &#34;N&#34;, &#34;Z&#34;, &#34;A&#34;, &#34;Other&#34;, &#34;EL&#34;, &#34;O&#34;, &#34;Other2&#34;, \
           &#34;Mass_Excess&#34;, &#34;dMass_Excess&#34;, &#34;Binding_Energy&#34;, &#34;dBinding_Energy&#34;, &#34;Other3&#34;, \
           &#34;Beta_Type&#34;, &#34;B_Decay_Energy&#34;, &#34;dB_Decay_Energy&#34;, &#34;Other4&#34;,
           &#34;Atomic_Mass_Micro&#34;, &#34;dAtomic_Mass_Micro&#34;]


    filename = os.path.join(originals_directory, &#34;mass16.txt&#34;)
    logging.info(&#34;MASS16: Reading data from {}&#34;.format(filename))
    data = pd.read_fwf(filename, colspecs=formatting, header=None, skiprows=39, names=column_names)

    logging.info(&#34;MASS16: Beginning formatting sequences...&#34;)
    data[&#34;O&#34;].fillna(value=&#34;Other&#34;, inplace=True)
    data = data.replace(value=np.nan, to_replace=&#34;*&#34;)

    for col in data.select_dtypes(include=[&#39;object&#39;]):
        data[col] = data[col].apply(lambda x: str(x).replace(&#34;#&#34;, &#34;&#34;))

    mass16_dtypes = [&#39;float64&#39;, &#39;int64&#39;, &#39;int64&#39;, &#39;int64&#39;, &#39;int64&#39;, &#39;float64&#39;, &#39;object&#39;, &#39;object&#39;, &#39;float64&#39;, &#39;float64&#39;,
        &#39;float64&#39;, &#39;float64&#39;, &#39;float64&#39;, &#39;float64&#39;, &#39;object&#39;, &#39;object&#39;, &#39;float64&#39;, &#39;float64&#39;, &#39;object&#39;, &#39;float64&#39;]

    for col, types in zip(data.columns, mass16_dtypes):
        data[col] = data[col].astype(types)
        
    for col in [&#34;Atomic_Mass_Micro&#34;]:
        data[col] = data[col].astype(str)
        data[col] = data[col].str.strip(&#34;\&#34;&#34;)
        data[col] = data[col].str.replace(&#34; &#34;, &#34;&#34;)
        data[col] = data[col].str.strip()

    data[&#34;Atomic_Mass_Micro&#34;] = data[&#34;Atomic_Mass_Micro&#34;].astype(float)
    data[&#34;B_Decay_Energy&#34;] = data[&#34;B_Decay_Energy&#34;].astype(float)

    data.drop(columns=[&#34;Page_Feed&#34;, &#34;Other&#34;, &#34;Other2&#34;, &#34;Other3&#34;, &#34;Beta_Type&#34;, &#34;Other4&#34;, &#34;NZ&#34;], inplace=True)

    data[&#34;Element_w_A&#34;] = data[&#34;A&#34;].astype(str) + data[&#34;EL&#34;]

    csv_name = os.path.join(saving_directory, &#34;AME_mass16.csv&#34;)
    logging.info(&#34;MASS16: Formatting done. Saving file to {}&#34;.format(csv_name))
    data.to_csv(csv_name, index=False)
    logging.info(&#34;MASS16: Succesfully formated mass16.txt file.&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="nucml.ame.parsing_utilities.read_rct1"><code class="name flex">
<span>def <span class="ident">read_rct1</span></span>(<span>originals_directory, saving_directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the rct1-16.txt file and creates a formatted CSV file. The rct1-16 file contains a variety of
features including neutron and proton separation energies and q-values for a variety of reactions.
For more information visit the IAEA webiste: <a href="https://www-nds.iaea.org/amdc/">https://www-nds.iaea.org/amdc/</a></p>
<p>It
is parse base on the Fortran formatting:
a1,i3,1x,a3,i3,1x,6(f10.2,f8.2)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>originals_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to the Atomic Mass Evaluation directory where the rct1-16.txt file is located.</dd>
<dt><strong><code>saving_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to save resulting formatted csv file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_rct1(originals_directory, saving_directory):
    &#34;&#34;&#34;Reads the rct1-16.txt file and creates a formatted CSV file. The rct1-16 file contains a variety of 
    features including neutron and proton separation energies and q-values for a variety of reactions.
    For more information visit the IAEA webiste: https://www-nds.iaea.org/amdc/
    
    It  is parse base on the Fortran formatting:
    a1,i3,1x,a3,i3,1x,6(f10.2,f8.2)

    Args:
        originals_directory (str): path to the Atomic Mass Evaluation directory where the rct1-16.txt file is located.
        saving_directory (str): path to save resulting formatted csv file.

    Returns:
        None
    &#34;&#34;&#34;
    formatting = ((0,1),(1,4),(4,5),(5,8),(8,11),(11,12),(12,22),(22,30),(30,40),
            (40,48),(48,58),(58,66),(66,76),(76,84),(84,94),(94,102),(102,112),(112,120))

    column_names = [&#34;Page_Feed&#34;, &#34;A&#34;, &#34;Other&#34;, &#34;EL&#34;, &#34;Z&#34;, &#34;Other2&#34;, &#34;S(2n)&#34;, &#34;dS(2n)&#34;, &#34;S(2p)&#34;, &#34;dS(2p)&#34;,
                &#34;Q(a)&#34;,  &#34;dQ(a)&#34;, &#34;Q(2B-)&#34;, &#34;dQ(2B-)&#34;, &#34;Q(ep)&#34;, &#34;dQ(ep)&#34;, &#34;Q(B-n)&#34;, &#34;dQ(B-n)&#34;]

    filename = os.path.join(originals_directory, &#34;rct1-16.txt&#34;)

    logging.info(&#34;RCT1: Reading data from {}&#34;.format(filename))
    data = pd.read_fwf(filename, colspecs=formatting, header=None, skiprows=39, names=column_names)
                    
    logging.info(&#34;RCT1: Beginning formatting sequences...&#34;)
    data = data.replace(to_replace=&#34;*&#34;, value=np.nan)
    data.drop(columns=[&#34;Other&#34;, &#34;Other2&#34;], inplace=True)

    for col in list(data.columns):
        data[col] = data[col].astype(str)
        data[col] = data[col].str.strip(&#34;\&#34;&#34;)
        data[col] = data[col].str.strip()
        data[col] = data[col].str.replace(&#34;#&#34;, &#34;.&#34;)

    for col in list(data.columns):
        if col == &#34;EL&#34;:
            pass
        else:
            data[col] = data[col].astype(float)

    data[[&#34;A&#34;, &#34;Z&#34;]] = data[[&#34;A&#34;, &#34;Z&#34;]].astype(int)
    data[&#34;N&#34;] = data[&#34;A&#34;] - data[&#34;Z&#34;]
    data[&#34;Element_w_A&#34;] = data[&#34;A&#34;].astype(str) + data[&#34;EL&#34;]
    data.drop(columns=[&#34;Page_Feed&#34;, &#34;A&#34;, &#34;EL&#34;, &#34;Z&#34;, &#34;N&#34;], inplace=True)

    csv_name = os.path.join(saving_directory, &#34;AME_rct1.csv&#34;)
    logging.info(&#34;RCT1: Formatting done. Saving file to {}&#34;.format(csv_name))
    data.to_csv(csv_name, index=False)
    logging.info(&#34;RCT1: Succesfully formated rct1-16.txt file.&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="nucml.ame.parsing_utilities.read_rct2"><code class="name flex">
<span>def <span class="ident">read_rct2</span></span>(<span>originals_directory, saving_directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the rct2-16.txt file and creates a formatted CSV file. The rct2-16 file contains a variety of
features including neutron and proton separation energies and q-values for a variety of reactions.
For more information visit the IAEA webiste: <a href="https://www-nds.iaea.org/amdc/">https://www-nds.iaea.org/amdc/</a></p>
<p>It
is parse base on the Fortran formatting:
a1,i3,1x,a3,i3,1x,6(f10.2,f8.2)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>originals_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to the Atomic Mass Evaluation directory where the rct2-16.txt file is located.</dd>
<dt><strong><code>saving_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to save resulting formatted csv file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_rct2(originals_directory, saving_directory):
    &#34;&#34;&#34;Reads the rct2-16.txt file and creates a formatted CSV file. The rct2-16 file contains a variety of 
    features including neutron and proton separation energies and q-values for a variety of reactions.
    For more information visit the IAEA webiste: https://www-nds.iaea.org/amdc/

    It  is parse base on the Fortran formatting:
    a1,i3,1x,a3,i3,1x,6(f10.2,f8.2)

    Args:
        originals_directory (str): path to the Atomic Mass Evaluation directory where the rct2-16.txt file is located.
        saving_directory (str): path to save resulting formatted csv file.

    Returns:
        None
    &#34;&#34;&#34;
    formatting = ((0,1),(1,4),(4,5),(5,8),(8,11),(11,12),(12,22),(22,30),(30,40),
            (40,48),(48,58),(58,66),(66,76),(76,84),(84,94),(94,102),(102,112),(112,120))

    column_names = [&#34;Page_Feed&#34;, &#34;A&#34;, &#34;Other&#34;, &#34;EL&#34;, &#34;Z&#34;, &#34;Other2&#34;, &#34;S(n)&#34;, &#34;dS(n)&#34;, &#34;S(p)&#34;, &#34;dS(p)&#34;, &#34;Q(4B-)&#34;,
                &#34;dQ(4B-)&#34;, &#34;Q(d,a)&#34;, &#34;dQ(d,a)&#34;, &#34;Q(p,a)&#34;, &#34;dQ(p,a)&#34;, &#34;Q(n,a)&#34;, &#34;dQ(n,a)&#34;]

    filename = os.path.join(originals_directory, &#34;rct2-16.txt&#34;)


    logging.info(&#34;RCT2: Reading data from {}&#34;.format(filename))
    data = pd.read_fwf(filename, colspecs=formatting, header=None, skiprows=39, names=column_names)

    logging.info(&#34;RCT2: Beginning formatting sequences...&#34;)
    data = data.replace(to_replace=&#34;*&#34;, value=np.nan)
    data.drop(columns=[&#34;Other&#34;, &#34;Other2&#34;], inplace=True)

    for col in list(data.columns):
        data[col] = data[col].astype(str)
        data[col] = data[col].str.strip(&#34;\&#34;&#34;)
        data[col] = data[col].str.strip()
        data[col] = data[col].str.replace(&#34;#&#34;, &#34;.&#34;)

    for col in list(data.columns):
        if col == &#34;EL&#34;:
            pass
        else:
            data[col] = data[col].astype(float)


    data[[&#34;A&#34;, &#34;Z&#34;]] = data[[&#34;A&#34;, &#34;Z&#34;]].astype(int)
    data[&#34;N&#34;] = data[&#34;A&#34;] - data[&#34;Z&#34;]
    data[&#34;Element_w_A&#34;] = data[&#34;A&#34;].astype(str) + data[&#34;EL&#34;]
    data.drop(columns=[&#34;Page_Feed&#34;, &#34;A&#34;, &#34;EL&#34;, &#34;Z&#34;, &#34;N&#34;], inplace=True)

    csv_name = os.path.join(saving_directory, &#34;AME_rct2.csv&#34;)
    logging.info(&#34;RCT2: Formatting done. Saving file to {}&#34;.format(csv_name))
    data.to_csv(csv_name, index=False)
    logging.info(&#34;RCT2: Succesfully formated rct2-16.txt file.&#34;)
    return None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nucml.ame" href="index.html">nucml.ame</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="nucml.ame.parsing_utilities.create_natural_element_data" href="#nucml.ame.parsing_utilities.create_natural_element_data">create_natural_element_data</a></code></li>
<li><code><a title="nucml.ame.parsing_utilities.get_all" href="#nucml.ame.parsing_utilities.get_all">get_all</a></code></li>
<li><code><a title="nucml.ame.parsing_utilities.get_ame_originals" href="#nucml.ame.parsing_utilities.get_ame_originals">get_ame_originals</a></code></li>
<li><code><a title="nucml.ame.parsing_utilities.merge_mass_rct" href="#nucml.ame.parsing_utilities.merge_mass_rct">merge_mass_rct</a></code></li>
<li><code><a title="nucml.ame.parsing_utilities.read_mass16" href="#nucml.ame.parsing_utilities.read_mass16">read_mass16</a></code></li>
<li><code><a title="nucml.ame.parsing_utilities.read_rct1" href="#nucml.ame.parsing_utilities.read_rct1">read_rct1</a></code></li>
<li><code><a title="nucml.ame.parsing_utilities.read_rct2" href="#nucml.ame.parsing_utilities.read_rct2">read_rct2</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>