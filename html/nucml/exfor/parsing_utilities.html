<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>nucml.exfor.parsing_utilities API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nucml.exfor.parsing_utilities</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import shutil
import logging
import numbers

import numpy as np
import pandas as pd
from natsort import natsorted
import sys

sys.path.append(&#34;..&#34;)

from nucml import general_utilities # pylint: disable=import-error
import nucml.objects.objects as objects # pylint: disable=import-error

ame_dir_path = os.path.abspath(&#34;../AME/&#34;)

def get_all(c4_list, heavy_path, tmp_path, mode=&#34;neutrons&#34;):
    &#34;&#34;&#34;Retrieves all avaliable information from all .c4 files. This function combines the
    proccesses defined on:

    - get_c4_names()
    - get_raw_datapoints()
    - get_authors()
    - get_years()
    - get_institutes()
    - get_dates()
    - get_titles()
    - get_references()
    - get_reaction_notation()
    - get_datapoints_per_experiment()

    It is optimized to run faster than running the individual functions.

    Args:
        c4_list (list): iterable containing the paths to c4 files.
        heavy_path (str): path to directory where heavy files are to be saved.
        tmp_path (str): path to directory where temporary files are to be saved.

    Returns:
        None

    &#34;&#34;&#34;

    if len(c4_list) != 0:
        # This will be appended to the previous directories
        tmp_path = os.path.join(tmp_path, &#34;Extracted_Text_&#34; + mode + &#34;/&#34;)
        heavy_path = os.path.join(heavy_path, &#34;EXFOR_&#34; + mode + &#34;/&#34;)
        general_utilities.initialize_directories_v2(tmp_path, reset=True)
        general_utilities.initialize_directories_v2(heavy_path, reset=True)


        cross_section_file = os.path.join(heavy_path, &#34;all_cross_sections.txt&#34;)
        if os.path.exists(cross_section_file):
            os.remove(cross_section_file)

        logging.info(&#34;EXFOR: Extracting experimental data, authors, years, institutes, and dates...&#34;)
        for i in c4_list:
            with open(i) as infile, \
                open(os.path.join(heavy_path, &#34;all_cross_sections.txt&#34;), &#39;a&#39;) as num_data, \
                open(os.path.join(tmp_path, &#39;authors.txt&#39;), &#39;a&#39;) as authors, \
                open(os.path.join(tmp_path, &#39;years.txt&#39;), &#39;a&#39;) as years, \
                open(os.path.join(tmp_path, &#39;institutes.txt&#39;), &#39;a&#39;) as institute, \
                open(os.path.join(tmp_path, &#39;entry.txt&#39;), &#39;a&#39;) as entry, \
                open(os.path.join(tmp_path, &#39;refcode.txt&#39;), &#39;a&#39;) as refcode, \
                open(os.path.join(tmp_path, &#39;dataset_num.txt&#39;), &#39;a&#39;) as dataset_num, \
                open(os.path.join(tmp_path, &#39;dates.txt&#39;), &#39;a&#39;) as date:
                copy = False
                for line in infile:
                    if line.startswith(r&#34;#AUTHOR1&#34;):
                        copy=False
                        authors.write(line)
                    elif line.startswith(r&#34;#YEAR&#34;):
                        copy=False
                        years.write(line)
                    elif line.startswith(r&#39;#ENTRY&#39;):
                        copy=False
                        entry.write(line)
                    elif line.startswith(r&#39;#REF-CODE&#39;):
                        copy=False
                        refcode.write(line)
                    elif line.startswith(r&#39;#DATASET&#39;):
                        if len(line) &gt; 16:
                            copy=False
                            dataset_num.write(line)                    
                    elif line.startswith(r&#34;#INSTITUTE&#34;):
                        copy=False
                        institute.write(line)
                    elif line.startswith(r&#34;#DATE&#34;):
                        copy=False
                        date.write(line)
                    elif line.startswith(r&#34;#---&gt;&lt;----&gt;o&lt;-&gt;&lt;--&gt;ooo&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-&gt;&lt;-----------------------&gt;&lt;---&gt;&lt;-&gt;o&#34;):
                        copy = True
                        continue
                    elif line.startswith(r&#34;#/DATA&#34;):
                        copy = False
                        continue
                    elif copy:
                        num_data.write(line)
                infile.close()
                authors.close()
                years.close()
                institute.close()
                date.close()
                num_data.close()
        logging.info(&#34;EXFOR: Finished extracting experimental data, authors, years, institutes, and dates.&#34;)
        logging.info(&#34;EXFOR: Extracting titles, references, and number of data points per experiment...&#34;)
        for i in c4_list:
            with open(i, &#34;r&#34;) as infile, \
                open(os.path.join(tmp_path, &#39;titles.txt&#39;), &#39;a&#39;) as titles, \
                open(os.path.join(tmp_path, &#39;references.txt&#39;), &#39;a&#39;) as references, \
                open(os.path.join(tmp_path, &#39;data_points_per_experiment_refined.txt&#39;), &#39;a&#39;) as data_points, \
                open(os.path.join(tmp_path, &#39;reaction_notations.txt&#39;), &#39;a&#39;) as reactions:
                lines = infile.readlines()
                for z, line in enumerate(lines):
                    if line.startswith(r&#34;#TITLE&#34;):
                        if lines[z + 2].startswith(r&#34;#+&#34;):
                            if lines[z + 4].startswith(r&#34;#+&#34;):
                                if lines[z + 6].startswith(r&#34;#+&#34;):
                                    titles.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+6].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                                else:
                                    titles.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                            else:
                                titles.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                        else:
                            titles.write(line)

                    elif line.startswith(r&#34;#REFERENCE&#34;):
                        if lines[z + 2].startswith(r&#34;#+&#34;):
                            if lines[z + 4].startswith(r&#34;#+&#34;):
                                if lines[z + 6].startswith(r&#34;#+&#34;):
                                    references.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+6].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                                else:
                                    references.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                            else:
                                references.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                        else:
                            references.write(line)

                    elif line.startswith(r&#34;#DATA &#34;):
                        if lines[z + 2].startswith(r&#34;#+&#34;):
                            if lines[z + 4].startswith(r&#34;#+&#34;):
                                if lines[z + 6].startswith(r&#34;#+&#34;):
                                    data_points.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+6].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                                else:
                                    data_points.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                            else:
                                data_points.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                        else:
                            data_points.write(line)


                    elif line.startswith(r&#34;#REACTION&#34;):
                        if lines[z + 2].startswith(r&#34;#+&#34;):
                            if lines[z + 4].startswith(r&#34;#+&#34;):
                                if lines[z + 6].startswith(r&#34;#+&#34;):
                                    reactions.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+6].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                                else:
                                    reactions.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                            else:
                                reactions.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                        else:
                            reactions.write(line)
                infile.close()
                titles.close()
                references.close()
                data_points.close()
                reactions.write(line)
        logging.info(&#34;EXFOR: Finished extracting titles, references, and number of data points per experiment.&#34;)
        logging.info(&#34;EXFOR: Formatting experimental data...&#34;)
        with open(cross_section_file) as infile, open(os.path.join(heavy_path, &#34;all_cross_sections_v1.txt&#34;), &#39;w&#39;) as outfile:
            for line in infile:
                if line.strip():
                    string = list(line)
                    # for i, j in enumerate([5, 11, 12, 15, 19, 22, 31, 40, 49, 58, 67, 76, 85, 94, 95, 122, 127]):
                    for i, j in enumerate([5, 11, 12, 15, 19, 20, 21, 22, 31, 40, 49, 58, 67, 76, 85, 94, 97, 122, 127, 130]):
                        string.insert(i + j, &#39;;&#39;)
                    outfile.write(&#34;&#34;.join(string))
        logging.info(&#34;EXFOR: Finished formating experimental data.&#34;)
        os.remove(cross_section_file)
        logging.info(&#34;EXFOR: Finished.&#34;)
        return None
    else:
        logging.error(&#34;EXFOR:  No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None

def csv_creator(heavy_path, tmp_path, mode, ame_dir=ame_dir_path, append_ame=True):
    &#34;&#34;&#34;Creates files containing all extracted features generated when using the get_all() function.
    The following CSV files are created:

    - EXFOR_mode_ORIGINAL.csv: Contains the EXFOR database in it&#39;s original state.
    - EXFOR_mode_ORIGINAL_w_AME.csv: Contains the same features as in the original CSV
        file plus AME data appended to each row. The appended AME is the original data therefore
        not containing natural element data.
    - EXFOR_mode_MF3_AME_no_RawNan: is a dataset created for personal use. It contains no
        missing values in both the EXFOR and the AME data entries. Furthermore, it is limited to 
        reaction data rows (MF=3). 

    Args:
        heavy_path (str): path to directory where heavy files are to be saved.
        tmp_path (str): path to directory where temporary files are to be saved.
        ame_dir (str): path to directory where proccessed AME files are saved.
        append_ame (bool): if True, the AME data will be appended to the final EXFOR CSV.
        fillna (bool): if True, an additional CSV file .

    Returns:
        None

    &#34;&#34;&#34;
    logging.info(&#34;EXFOR CSV: Reading data points from {}/all_cross_sections_v1.txt file into a DataFrame...&#34;.format(heavy_path))
    colnames = [&#34;Projectile&#34;, &#34;Target_ZA&#34;, &#34;Target_Metastable_State&#34;, &#34;MF&#34;, &#34;MT&#34;, &#34;Product_Metastable_State&#34;, \
                &#34;EXFOR_Status&#34;, &#34;Center_of_Mass_Flag&#34;, &#34;Energy&#34;,  &#34;dEnergy&#34;,  &#34;Data&#34;, &#34;dData&#34;,   &#34;Cos/LO&#34;,   &#34;dCos/LO&#34;, \
                &#34;ELV/HL&#34;,  &#34;dELV/HL&#34;, &#34;I78&#34;, &#34;Short_Reference&#34;, &#34;EXFOR_Accession_Number&#34;, &#34;EXFOR_SubAccession_Number&#34;, \
                &#34;EXFOR_Pointer&#34;]
    df = pd.read_csv(os.path.join(heavy_path, &#34;all_cross_sections_v1.txt&#34;), names=colnames, header=None, index_col=False, sep=&#34;;&#34;)

    ########################################################################################################
    ########################### FORMATTING CATEGORICAL AND STRING DATA #####################################
    ########################################################################################################

    logging.info(&#34;EXFOR CSV: Formatting data (this may take a couple minutes)...&#34;)
    # make string version of original column
    df[&#39;Target_ZA&#39;] = df[&#39;Target_ZA&#39;].astype(str)

    # Making Sure all rows have the same number of values
    max_length = 5
    df.Target_ZA = df.Target_ZA.apply(lambda x: &#39;0&#39;*(max_length - len(x)) + x)

    # Target feature is formated as ZZAAA
    df[&#39;Z&#39;] = df[&#39;Target_ZA&#39;].str[0:2].astype(int).fillna(0)
    df[&#39;A&#39;] = df[&#39;Target_ZA&#39;].str[2:5].astype(int).fillna(0)

    # Calculating number of neutrons = mass number - protons
    df[&#39;N&#39;] = df[&#39;A&#39;] - df[&#34;Z&#34;]

    metastate_dict = {&#34; &#34;: &#34;All_or_Total&#34;, &#34;G&#34;: &#34;Ground&#34;, &#34;1&#34;: &#34;M1&#34;, &#34;2&#34;: &#34;M2&#34;, &#34;3&#34;: &#34;M3&#34;, &#34;4&#34;: &#34;M4&#34;, 
                    &#34;5&#34;: &#34;M5&#34;, &#34;?&#34;: &#34;Unknown&#34;, &#34;+&#34;: &#34;More_than_1&#34;, &#34;T&#34;: &#34;All_or_Total&#34;}
    df = df.replace({&#34;Target_Metastable_State&#34;: metastate_dict, &#34;Product_Metastable_State&#34;: metastate_dict})

    exfor_status_dict = {&#34;U&#34;:&#34;Un_normalized&#34;, &#34;A&#34;:&#34;Approved_by_Author&#34;, &#34;C&#34;:&#34;Correlated&#34;, &#34;D&#34;:&#34;Dependent&#34;, 
                     &#34;O&#34;:&#34;Outdated&#34;, &#34;P&#34;:&#34;Preliminary&#34;, &#34;R&#34;:&#34;Re_normalized&#34;, &#34;S&#34;:&#34;Superseded&#34;, &#34; &#34;:&#34;Other&#34;}
    df = df.replace({&#34;EXFOR_Status&#34;: exfor_status_dict})

    df = df.replace({&#34;Center_of_Mass_Flag&#34;: {&#34;C&#34;:&#34;Center_of_Mass&#34;, &#34; &#34;:&#34;Lab&#34;}})


    ########################################################################################################
    ################################### FORMATTING NUMERICAL DATA ##########################################
    ########################################################################################################
    # Defining Numerical Columns to Fix and casting them as strings
    cols = [&#34;Energy&#34;, &#34;dEnergy&#34;, &#34;Data&#34;, &#34;dData&#34;, &#34;Cos/LO&#34;, &#34;dCos/LO&#34;, &#34;ELV/HL&#34;, &#34;dELV/HL&#34;]
    df[cols] = df[cols].astype(str)

    # df[cols] = df[cols].replace(to_replace=&#34;         &#34;, value=&#34;0.0000000&#34;)
    df[cols] = df[cols].replace(to_replace=&#34;         &#34;, value=np.nan)

    # We now strip values that may contain quatation marks and starting and trailing spaces
    for col in cols:
        df[col] = df[col].str.strip(&#34;\&#34;&#34;)
        df[col] = df[col].str.strip()

    # df[cols] = df[cols].replace(to_replace=&#34;&#34;, value=&#34;0.0000000&#34;)
    df[cols] = df[cols].replace(to_replace=&#34;&#34;, value=np.nan)

    # For the numerical values we know per formatting that each of them should be 9 characters in length
    max_length = 9

    for col in cols:
        df[col] = df[col].apply(lambda x: x if pd.isnull(x) else &#39; &#39;*(max_length - len(x)) + x)

    # Add appropiate formating for python to recognize it as numerical
    for col in cols:
        new_col = []
        values = df[col].values
        for x in values:
            if pd.isnull(x):
                new_col.append(x)
            elif &#34;+&#34; == x[7]:
                y = x[0:7]
                z = x[7:]
                new_col.append(y + &#34;E&#34; + z)
            elif &#34;+&#34; == x[6]:
                y = x[0:6]
                z = x[6:]
                new_col.append(y + &#34;E&#34; + z)
            elif &#34;-&#34; == x[7]:
                y = x[0:7]
                z = x[7:]
                new_col.append(y + &#34;E&#34; + z)
            elif &#34;-&#34; == x[6]:
                y = x[0:6]
                z = x[6:]
                new_col.append(y + &#34;E&#34; + z)
            else:
                new_col.append(x)
        df[col] = new_col

    # We now convert the columns to numerical
    for col in cols:
        df[col] = df[col].astype(float)
        logging.info(&#34;EXFOR CSV: Finished converting {} to float.&#34;.format(col))

    cat_cols = [&#34;Target_Metastable_State&#34;, &#34;MF&#34;, &#34;MT&#34;, &#34;I78&#34;, &#34;Product_Metastable_State&#34;, &#34;Center_of_Mass_Flag&#34;]

    # Convering all columns to strings and stripping whitespace
    for col in cat_cols:
        df[col] = df[col].astype(str)
        df[col] = df[col].str.strip(&#34;\&#34;&#34;)
        df[col] = df[col].str.strip()

    # Replace empty values in I78 for L representing Low
    df = df.replace({&#34;I78&#34;: {&#34;E2&#34;:&#34;Secondary_Energy&#34;, &#34;LVL&#34;:&#34;Level&#34;, &#34;HL&#34;:&#34;Half_Life&#34;, &#34;DLV&#34;:&#34;Level_Range&#34;, 
                         &#34;EXC&#34;:&#34;Excitation&#34;, &#34;DE2&#34;:&#34;Secondary_Energy_Range&#34;, &#34;MIN&#34;:&#34;Minimum_Energy&#34;, 
                         &#34;MAX&#34;:&#34;Maximum_Energy&#34;, &#34;&#34;:&#34;Other&#34;}})

    df.drop(columns=[&#39;Target_ZA&#39;], inplace=True)

    ########################################################################################################
    ################################# APPENDING OTHER INFORMATION ##########################################
    ########################################################################################################

    logging.info(&#34;EXFOR CSV: Reading .txt files from {} into DataFrames...&#34;.format(tmp_path))
    # Reading experiments reaction notation
    df1 = pd.read_csv(os.path.join(tmp_path, &#34;reaction_notations.txt&#34;), delim_whitespace=True, header=None)
    df1.columns = [&#34;Reaction&#34;, &#34;Reaction_Notation&#34;]

    # Reading Experiment Titles
    df2 = pd.read_csv(os.path.join(tmp_path, &#34;titles.txt&#34;), sep=&#34;#TITLE      &#34;, header=None, engine=&#34;python&#34;)
    df2.columns = [&#34;Keyword&#34;, &#34;Title&#34;]

    # Reading Data Points per Experiment
    df3 = pd.read_csv(os.path.join(tmp_path, &#34;data_points_per_experiment_refined.txt&#34;),  delim_whitespace=True, header=None)
    df3.columns = [&#34;Data&#34;, &#34;Multiple&#34;]

    # Reading Experiment Year
    df4 = pd.read_csv(os.path.join(tmp_path, &#34;years.txt&#34;), delim_whitespace=True, header=None)
    df4.columns = [&#34;Keyword&#34;, &#34;Year&#34;]

    # Reading Experiment Date
    df5 = pd.read_csv(os.path.join(tmp_path, &#34;authors.txt&#34;), sep=&#34;    &#34;, header=None, engine=&#34;python&#34;)
    df5.columns = [&#34;Keyword&#34;, &#34;Author&#34;]

    # Reading Experiment Institute
    df6 = pd.read_csv(os.path.join(tmp_path, &#34;institutes.txt&#34;), sep=&#34;  &#34;, header=None, engine=&#34;python&#34;)
    df6.columns = [&#34;Keyword&#34;, &#34;Institute&#34;]

    # Reading Experiment Year
    df7 = pd.read_csv(os.path.join(tmp_path, &#34;dates.txt&#34;), delim_whitespace=True, header=None)
    df7.columns = [&#34;Keyword&#34;, &#34;Date&#34;]

    # Reading Experiment Refere
    df8 = pd.read_csv(os.path.join(tmp_path, &#34;references.txt&#34;), sep=&#34;#REFERENCE  &#34;, header=None, engine=&#34;python&#34;)
    df8.columns = [&#34;Keyword&#34;, &#34;Reference&#34;]

    # Reading Dataset Number
    df9 = pd.read_csv(os.path.join(tmp_path, &#34;dataset_num.txt&#34;), sep=&#34;#DATASET    &#34;, header=None, engine=&#34;python&#34;)
    df9.columns = [&#34;Keyword&#34;, &#34;Dataset_Number&#34;]

    # Reading EXFOR entry number
    df10 = pd.read_csv(os.path.join(tmp_path, &#34;entry.txt&#34;), sep=&#34;#ENTRY      &#34;, header=None, engine=&#34;python&#34;)
    df10.columns = [&#34;Keyword&#34;, &#34;EXFOR_Entry&#34;]

    # Reading reference code
    df11 = pd.read_csv(os.path.join(tmp_path, &#34;refcode.txt&#34;), sep=&#34;#REF-CODE   &#34;, header=None, engine=&#34;python&#34;)
    df11.columns = [&#34;Keyword&#34;, &#34;Reference_Code&#34;]


    # Merging Datapoints, notation and titles and expanding based on datapoints
    logging.info(&#34;EXFOR CSV: Expanding information based on the number of datapoints per experimental campaign...&#34;)
    pre_final = pd.concat([df3, df1, df2, df4, df5, df6, df7, df8, df9, df10, df11], axis=1)
    final = pre_final.reindex(pre_final.index.repeat(pre_final.Multiple))
    final[&#39;position&#39;] = final.groupby(level=0).cumcount() + 1
    
    # Indexing only required information and saving file
    final = final[[&#34;Reaction_Notation&#34;, &#34;Title&#34;, &#34;Year&#34;, &#34;Author&#34;, &#34;Institute&#34;, &#34;Date&#34;, &#34;Reference&#34;, 
                &#34;Dataset_Number&#34;, &#34;EXFOR_Entry&#34;, &#34;Reference_Code&#34;]]

    # Reset Indexes to make copying faster
    df = df.reset_index(drop=True)
    final = final.reset_index(drop=True)

    logging.info(&#34;EXFOR CSV: Appending information to main DataFrame...&#34;)
    # Assign newly extracted data to main dataframe
    df[&#34;Reaction_Notation&#34;] = final[&#34;Reaction_Notation&#34;]
    df[&#34;Title&#34;] = final[&#34;Title&#34;]
    df[&#34;Year&#34;] = final[&#34;Year&#34;]
    df[&#34;Author&#34;] = final[&#34;Author&#34;]
    df[&#34;Institute&#34;] = final[&#34;Institute&#34;]
    df[&#34;Date&#34;] = final[&#34;Date&#34;]
    df[&#34;Reference&#34;] = final[&#34;Reference&#34;]
    df[&#34;Dataset_Number&#34;] = final[&#34;Dataset_Number&#34;]
    df[&#34;EXFOR_Entry&#34;] = final[&#34;EXFOR_Entry&#34;]
    df[&#34;Reference_Code&#34;] = final[&#34;Reference_Code&#34;]

    df.Title = df.Title.fillna(&#34;No Title Found. Check EXFOR.&#34;)
    df.Reference = df.Reference.fillna(&#34;No Reference Found. Check EXFOR.&#34;)
    df.Short_Reference = df.Short_Reference.fillna(&#34;No Reference Found. Check EXFOR.&#34;)
    df.Reference_Code = df.Reference_Code.fillna(&#34;No Reference Code Found. Check EXFOR.&#34;)
    df.Author = df.Author.fillna(&#34;No Author Found. Check EXFOR.&#34;)
    df.EXFOR_Pointer = df.EXFOR_Pointer.fillna(&#34;No Pointer&#34;)

    df.EXFOR_Pointer = df.EXFOR_Pointer.apply(lambda x: str(int(x)) if isinstance(x, numbers.Number) else x)
    df.Date = df.Date.apply(lambda x: str(x)[:4] + &#34;/&#34; + str(x)[4:6] + &#34;/&#34; + str(x)[6:])
    df.EXFOR_SubAccession_Number = df.EXFOR_SubAccession_Number.astype(int)
    df.Institute = df.Institute.apply(lambda x: x.replace(&#34;(&#34;, &#34;&#34;).replace(&#34;)&#34;, &#34;&#34;))

    df = df.replace({&#39;Projectile&#39;: {1: &#34;neutron&#34;, 1001: &#34;proton&#34;, 2003:&#34;helion&#34;, 0:&#34;gamma&#34;, 1002:&#34;deuteron&#34;, 2004:&#34;alpha&#34;}})

    if df.Projectile.unique()[0] == &#34;neutron&#34;:
        Projectile_Z, Projectile_A, Projectile_N = 0, 1, 1
    elif df.Projectile.unique()[0] == &#34;proton&#34;:
        Projectile_Z, Projectile_A, Projectile_N = 1, 1, 0
    elif df.Projectile.unique()[0] == &#34;helion&#34;:
        Projectile_Z, Projectile_A, Projectile_N = 2, 3, 1
    elif df.Projectile.unique()[0] == &#34;gamma&#34;:
        Projectile_Z, Projectile_A, Projectile_N = 0, 0, 0
    elif df.Projectile.unique()[0] == &#34;deuteron&#34;:
        Projectile_Z, Projectile_A, Projectile_N = 1, 2, 1
    elif df.Projectile.unique()[0] == &#34;alpha&#34;:
        Projectile_Z, Projectile_A, Projectile_N = 2, 4, 2
    df[&#34;Projectile_Z&#34;] = Projectile_Z
    df[&#34;Projectile_A&#34;] = Projectile_A
    df[&#34;Projectile_N&#34;] = Projectile_N

    element_w_a = objects.load_zan()
    element_w_a = pd.DataFrame.from_dict(element_w_a, orient=&#39;index&#39;)
    # There are no molecular
    element_w_a.loc[&#39;12019&#39;] = [&#39;Heavy Water&#39;, 19, 1, 20, &#34;Heavy Water&#34;]

    df = df.merge(element_w_a, on=[&#39;N&#39;, &#39;Z&#39;, &#39;A&#39;], how=&#39;left&#39;)

    df[[&#34;EXFOR_Accession_Number&#34;, &#34;Dataset_Number&#34;, &#34;EXFOR_Entry&#34;]]  = df[[&#34;EXFOR_Accession_Number&#34;, &#34;Dataset_Number&#34;, &#34;EXFOR_Entry&#34;]].astype(str)
    csv_name = os.path.join(heavy_path, &#34;EXFOR_&#34; + mode + &#34;_ORIGINAL.csv&#34;)
    logging.info(&#34;EXFOR CSV: Saving EXFOR CSV file to {}...&#34;.format(csv_name))
    df.to_csv(csv_name, index=False)

    if append_ame:
        logging.info(&#34;EXFOR CSV: Reading AME file...&#34;)
        df_workxs = df.copy()
        masses = pd.read_csv(ame_dir + &#34;AME_Natural_Properties_w_NaN.csv&#34;).rename(
            columns={&#39;N&#39;: &#39;Neutrons&#39;, &#39;A&#39;: &#39;Mass_Number&#39;, &#39;Neutrons&#39;:&#39;N&#39;, &#39;Mass_Number&#39;:&#39;A&#39;, &#39;Flag&#39;:&#39;Element_Flag&#39;})
        df_workxs = df_workxs.reset_index(drop=True)
        masses = masses.reset_index(drop=True)
        logging.info(&#34;EXFOR CSV: Appending AME data to EXFOR File...&#34;)
        df = df_workxs.merge(masses, on=[&#39;N&#39;, &#39;Z&#39;], how=&#39;left&#39;)
        df = df.drop(columns=[&#34;A_x&#34;, &#34;A_y&#34;, &#34;N&#34;, &#34;EL&#34;]).rename(columns={&#39;Neutrons&#39;: &#39;N&#39;, &#39;Mass_Number&#39;:&#39;A&#39;})
        df = df[~df[&#39;N&#39;].isnull()]
        df[[&#34;N&#34;, &#34;A&#34;]] = df[[&#34;N&#34;, &#34;A&#34;]].astype(int)
        csv_name = os.path.join(heavy_path, &#34;EXFOR_&#34; + mode + &#34;_ORIGINAL_w_AME.csv&#34;)
        logging.info(&#34;EXFOR CSV: Saving EXFOR CSV file to {}...&#34;.format(csv_name))
        df.to_csv(csv_name, index=False)
    return None

def impute_original_exfor(heavy_path, tmp_path, mode, ame_dir=ame_dir_path, append_ame=True, MF_number=&#34;3&#34;):
    csv_name = os.path.join(heavy_path, &#34;EXFOR_&#34; + mode + &#34;_ORIGINAL.csv&#34;)
    df = pd.read_csv(csv_name)

    if append_ame:
        logging.info(&#34;EXFOR CSV: Reading AME file...&#34;)
        df_workxs = df.copy()
        masses = pd.read_csv(ame_dir + &#34;AME_Natural_Properties_no_NaN.csv&#34;).rename(
            columns={&#39;N&#39;: &#39;Neutrons&#39;, &#39;A&#39;: &#39;Mass_Number&#39;, &#39;Neutrons&#39;:&#39;N&#39;, &#39;Mass_Number&#39;:&#39;A&#39;, &#39;Flag&#39;:&#39;Element_Flag&#39;})

        df_workxs = df_workxs.reset_index(drop=True)
        masses = masses.reset_index(drop=True)
        logging.info(&#34;EXFOR CSV: Appending AME data to EXFOR File...&#34;)
        df = df_workxs.merge(masses, on=[&#39;N&#39;, &#39;Z&#39;], how=&#39;left&#39;)
        df = df.drop(columns=[&#34;A_x&#34;, &#34;A_y&#34;, &#34;N&#34;, &#34;EL&#34;]).rename(columns={&#39;Neutrons&#39;: &#39;N&#39;, &#39;Mass_Number&#39;:&#39;A&#39;})
        df = df[~df[&#39;N&#39;].isnull()]
        df[[&#34;N&#34;, &#34;A&#34;]] = df[[&#34;N&#34;, &#34;A&#34;]].astype(int)
        df[&#34;O&#34;].fillna(value=&#34;Other&#34;, inplace=True)

    logging.info(&#34;EXFOR CSV: Creating new CSV file with only MF=3 data...&#34;)
    df.MF = df.MF.astype(str)
    df.MT = df.MT.astype(str)
    df = df[df[&#34;MF&#34;] == MF_number]

    # We get rid of heavy water measurments
    if MF_number == &#34;3&#34;:
        logging.info(&#34;...&#34;)

    columns_drop = [&#34;MF&#34;, &#34;Cos/LO&#34;, &#34;dCos/LO&#34;]
    df = df.drop(columns=columns_drop)

    logging.info(&#34;EXFOR CSV: Filling dEnergy, dData, and dELV by reaction channel...&#34;)
    df[&#34;Uncertainty_E&#34;] = df[&#34;dEnergy&#34;]/df[&#34;Energy&#34;]
    df[&#34;Uncertainty_D&#34;] = df[&#34;dData&#34;]/df[&#34;Data&#34;]
    df[&#34;Uncertainty_ELV&#34;] = df[&#34;dELV/HL&#34;]/df[&#34;ELV/HL&#34;]

    df[&#34;Uncertainty_E&#34;] = df[[&#34;MT&#34;, &#34;Uncertainty_E&#34;]].groupby(&#34;MT&#34;).transform(lambda x: x.fillna(x.mean()))
    df[&#34;Uncertainty_D&#34;] = df[[&#34;MT&#34;, &#34;Uncertainty_D&#34;]].groupby(&#34;MT&#34;).transform(lambda x: x.fillna(x.mean()))
    df[&#34;Uncertainty_ELV&#34;] = df[[&#34;MT&#34;, &#34;Uncertainty_ELV&#34;]].groupby(&#34;MT&#34;).transform(lambda x: x.fillna(x.mean()))

    logging.info(&#34;EXFOR CSV: Filling dEnergy, dData, and dELV by Institute...&#34;)
    df[&#34;Uncertainty_E&#34;] = df[[&#34;Institute&#34;, &#34;Uncertainty_E&#34;]].groupby(&#34;Institute&#34;).transform(lambda x: x.fillna(x.mean()))
    df[&#34;Uncertainty_D&#34;] = df[[&#34;Institute&#34;, &#34;Uncertainty_D&#34;]].groupby(&#34;Institute&#34;).transform(lambda x: x.fillna(x.mean()))
    df[&#34;Uncertainty_ELV&#34;] = df[[&#34;Institute&#34;, &#34;Uncertainty_ELV&#34;]].groupby(&#34;Institute&#34;).transform(lambda x: x.fillna(x.mean()))

    logging.info(&#34;EXFOR CSV: Filling dEnergy, dData, and dELV by Isotope...&#34;)
    df[&#34;Uncertainty_E&#34;] = df[[&#34;Isotope&#34;, &#34;Uncertainty_E&#34;]].groupby(&#34;Isotope&#34;).transform(lambda x: x.fillna(x.mean()))
    df[&#34;Uncertainty_D&#34;] = df[[&#34;Isotope&#34;, &#34;Uncertainty_D&#34;]].groupby(&#34;Isotope&#34;).transform(lambda x: x.fillna(x.mean()))
    df[&#34;Uncertainty_ELV&#34;] = df[[&#34;Isotope&#34;, &#34;Uncertainty_ELV&#34;]].groupby(&#34;Isotope&#34;).transform(lambda x: x.fillna(x.mean()))

    df[&#34;Uncertainty_ELV&#34;] = df[[&#34;I78&#34;, &#34;Uncertainty_ELV&#34;]].groupby(&#34;I78&#34;).transform(lambda x: x.fillna(x.mean()))

    df.dEnergy = df.dEnergy.fillna(df.Energy * df.Uncertainty_E)
    df.dData = df.dData.fillna(df.Data * df.Uncertainty_D)
    df[&#34;dELV/HL&#34;] = df[&#34;dELV/HL&#34;].fillna(df[&#34;ELV/HL&#34;] * df[&#34;Uncertainty_ELV&#34;])

    df.Uncertainty_D = df.Uncertainty_D.replace(to_replace=np.inf, value=0)
    df.dData = df.dData.replace(to_replace=np.nan, value=0)
    df[&#34;dELV/HL&#34;] = df[&#34;dELV/HL&#34;].replace(to_replace=np.nan, value=0)
    df[&#34;ELV/HL&#34;] = df[&#34;ELV/HL&#34;].replace(to_replace=np.nan, value=0)

    df.fillna(value=0, inplace=True)

    df[&#34;Nucleus_Radius&#34;] = 1.25 * np.power(df[&#34;A&#34;], 1/3)
    df[&#34;Neutron_Nucleus_Radius_Ratio&#34;] = 0.8 / df[&#34;Nucleus_Radius&#34;]
    
    # Use this for ordering
    new_order = list(df.columns)[:35]
    new_order_2 = list(df.columns)[-6:]
    new_order.extend(new_order_2)
    nuclear_data_target = list(df.columns)[35:-6]
    new_order.extend(nuclear_data_target)

    df = df[new_order]

    df = df.drop(columns=[&#34;Uncertainty_D&#34;, &#34;Uncertainty_E&#34;, &#34;Uncertainty_ELV&#34;])

    logging.info(&#34;EXFOR CSV: Dropping RAW experimental datapoints...&#34;)
    df = df[~df.Reaction_Notation.str.contains(&#34;RAW&#34;)]

    df = df[~(df.Data &lt; 0)]

    logging.info(&#34;EXFOR CSV: Saving MF3 NaN Imputed RAW Free EXFOR CSV...&#34;)
    df.to_csv(os.path.join(heavy_path, &#34;EXFOR_&#34; + mode + &#34;_MF3_AME_no_RawNaN.csv&#34;), index=False)
    logging.info(&#34;Finished&#34;)
    return None
    
def get_c4_names(originals_directory):
    &#34;&#34;&#34;Searches given directory for EXFOR-generated C4 files.  It returns a list of relative paths for each encountered file.

    Args:
        originals_directory (str): path to the directory containing all .c4 files..

    Returns:
        list: contains relative path to each encountered .c4 file. None if no files are found.
    &#34;&#34;&#34;
    logging.info(&#34;C4: Searching {} directory for .c4 files...&#34;.format(originals_directory))

    names = natsorted(general_utilities.get_files_w_extension(originals_directory, &#34;.c4&#34;))
    logging.info(&#34;C4: Finished. Found {} .c4 files.&#34;.format(len(names)))
    return names


########################################################################################################
################### DEPRECATED - ALL FUNCTIONS TAKE PLACE IN THE get_all() FUNCTION ####################
########################################################################################################

def get_raw_datapoints(c4_list, saving_directory):
    &#34;&#34;&#34;Collects the data section of the c4 files into a single TXT file.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files (needs to hold more than 6 GB of information).

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        if os.path.exists(saving_directory + &#34;/all_cross_sections.txt&#34;):
            logging.info(&#34;RAW DATAPOINTS: An all_cross_sections.txt file already exists. Removing to create new file...&#34;)
            os.remove(os.path.join(saving_directory, &#34;/all_cross_sections.txt&#34;))

        logging.info(&#34;RAW DATAPOINTS: Processing {} .c4 files.&#34;.format(len(c4_list)))

        logging.info(&#34;RAW DATAPOINTS: Extracting experimental data from all .c4 EXFOR files...&#34;)
        for i in c4_list:
            with open(i) as infile, open(os.path.join(saving_directory, &#34;all_cross_sections.txt&#34;), &#39;a&#39;) as outfile:
                copy = False
                for line in infile:
                    if line.startswith(r&#34;#---&gt;&lt;----&gt;o&lt;-&gt;&lt;--&gt;ooo&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-&gt;&lt;-----------------------&gt;&lt;---&gt;&lt;-&gt;o&#34;):
                        copy = True
                        continue
                    elif line.startswith(r&#34;#/DATA&#34;):
                        copy = False
                        continue
                    elif copy:
                        outfile.write(line)
                infile.close()
                outfile.close()
        logging.info(&#34;RAW DATAPOINTS: Finished extracting all experimental data.&#34;)

        logging.info(&#34;RAW DATAPOINTS: Formatting extracted data using EXFORs fortran format...&#34;)
        with open(os.path.join(saving_directory, &#34;all_cross_sections.txt&#34;)) as infile, open(os.path.join(saving_directory, &#34;all_cross_sections_v1.txt&#34;), &#39;w&#39;) as outfile:
            for line in infile:
                if line.strip():
                    string = list(line)
                    for i, j in enumerate([5, 11, 12, 15, 19, 22, 31, 40, 49, 58, 67, 76, 85, 94, 95, 122, 127]):
                        string.insert(i + j, &#39;;&#39;)
                    outfile.write(&#34;&#34;.join(string))
        logging.info(&#34;RAW DATAPOINTS: Finished formating EXFOR data. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;all_cross_sections_v1.txt&#34;)))
        os.remove(os.path.join(saving_directory + &#34;all_cross_sections.txt&#34;))
        return None
    else:
        logging.error(&#34;RAW DATAPOINTS: No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None

def get_authors(c4_list, saving_directory):
    &#34;&#34;&#34;Retrieves the avaliable Authors from all entries in all .c4 files.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files.

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        logging.info(&#34;AUTHORS: Extracting...&#34;)
        for i in c4_list:
            with open(i) as infile, open(os.path.join(saving_directory, &#39;authors.txt&#39;), &#39;a&#39;) as outfile:
                for line in infile:
                    if line.startswith(r&#34;#AUTHOR1&#34;):
                        outfile.write(line)
        logging.info(&#34;AUTHORS: Finished. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;authors.txt&#34;)))
        return None
    else:
        logging.error(&#34;AUTHORS: No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None

def get_years(c4_list, saving_directory):
    &#34;&#34;&#34;Retrieves the years from from all .c4 exfor entries.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files.

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        logging.info(&#34;YEARS: Extracting...&#34;)
        for i in c4_list:
            with open(i) as infile, open(os.path.join(saving_directory, &#39;years.txt&#39;), &#39;a&#39;) as outfile:
                for line in infile:
                    if line.startswith(r&#34;#YEAR&#34;):
                        outfile.write(line)
        logging.info(&#34;YEARS: Finished. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;years.txt&#34;)))
        return None
    else:
        logging.error(&#34;YEARS: No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None

def get_institutes(c4_list, saving_directory):
    &#34;&#34;&#34;Retrieves the avaliable Institutes from all .c4 files.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files.

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        logging.info(&#34;INSTITUTES: Extracting...&#34;)
        for i in c4_list:
            with open(i) as infile, open(os.path.join(saving_directory, &#39;institutes.txt&#39;), &#39;a&#39;) as outfile:
                for line in infile:
                    if line.startswith(r&#34;#INSTITUTE&#34;):
                        outfile.write(line)
        logging.info(&#34;INSTITUTES: Finished. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;institutes.txt&#34;)))
        return None
    else:
        logging.error(&#34;INSTITUTES: No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None

def get_dates(c4_list, saving_directory):
    &#34;&#34;&#34;Retrieves the avaliable Dates from all .c4 files.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files.

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        logging.info(&#34;DATES: Extracting...&#34;)
        for i in c4_list:
            with open(i) as infile, open(os.path.join(saving_directory, &#39;dates.txt&#39;), &#39;a&#39;) as outfile:
                for line in infile:
                    if line.startswith(r&#34;#DATE&#34;):
                        outfile.write(line)
        logging.info(&#34;DATES: Finished. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;dates.txt&#34;)))
        return None
    else:
        logging.error(&#34;DATES: No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None

def get_titles(c4_list, saving_directory):
    &#34;&#34;&#34;Retrieves the avaliable experiment Titles from all .c4 files.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files.

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        logging.info(&#34;TITLES: Extracting...&#34;)
        for i in c4_list:
            with open(i, &#34;r&#34;) as infile, open(os.path.join(saving_directory, &#39;titles.txt&#39;), &#39;a&#39;) as outfile:
                lines = infile.readlines()
                for z, line in enumerate(lines):
                    if line.startswith(r&#34;#TITLE&#34;):
                        if lines[z + 2].startswith(r&#34;#+&#34;):
                            if lines[z + 4].startswith(r&#34;#+&#34;):
                                if lines[z + 6].startswith(r&#34;#+&#34;):
                                    outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+6].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                                else:
                                    outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                            else:
                                outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                        else:
                            outfile.write(line)
        logging.info(&#34;TITLES: Finished. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;titles.txt&#34;)))
        return None
    else:
        logging.error(&#34;TITLES: No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None

def get_references(c4_list, saving_directory):
    &#34;&#34;&#34;Retrieves the avaliable references for all experiments from all .c4 files.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files.

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        logging.info(&#34;REFERENCES: Extracting...&#34;)
        for i in c4_list:
            with open(i, &#34;r&#34;) as infile, open(os.path.join(saving_directory, &#39;references.txt&#39;), &#39;a&#39;) as outfile:
                lines = infile.readlines()
                for z, line in enumerate(lines):
                    if line.startswith(r&#34;#REFERENCE&#34;):
                        if lines[z + 2].startswith(r&#34;#+&#34;):
                            if lines[z + 4].startswith(r&#34;#+&#34;):
                                if lines[z + 6].startswith(r&#34;#+&#34;):
                                    outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+6].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                                else:
                                    outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                            else:
                                outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                        else:
                            outfile.write(line)
        logging.info(&#34;REFERENCES: Finished. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;references.txt&#34;)))
        return None
    else:
        logging.error(&#34;REFERENCES: No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None

def get_reaction_notations(c4_list, saving_directory):
    &#34;&#34;&#34;Retrieves the avaliable reaction notation from all .c4 files.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files.

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        logging.info(&#34;REACTION NOTATION: Extracting...&#34;)
        for i in c4_list:
            with open(i, &#34;r&#34;) as infile, open(os.path.join(saving_directory, &#39;reaction_notations.txt&#39;), &#39;a&#39;) as outfile:
                lines = infile.readlines()
                for z, line in enumerate(lines):
                    if line.startswith(r&#34;#REACTION&#34;):
                        if lines[z + 2].startswith(r&#34;#+&#34;):
                            if lines[z + 4].startswith(r&#34;#+&#34;):
                                if lines[z + 6].startswith(r&#34;#+&#34;):
                                    outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+6].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                                else:
                                    outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                            else:
                                outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                        else:
                            outfile.write(line)
        logging.info(&#34;REACTION NOTATION: Finished. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;reaction_notation.txt&#34;)))
        return None
    else:
        logging.error(&#34;REACTION NOTATION: No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None

def get_datapoints_per_experiment(c4_list, saving_directory):
    &#34;&#34;&#34;Retrieves the number of data points per experiment from all .c4 files.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files.

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        logging.info(&#34;DATA POINTS: Extracting...&#34;)
        for i in c4_list:
            with open(i, &#34;r&#34;) as infile, open(os.path.join(saving_directory, &#39;data_points_per_experiment_refined.txt&#39;), &#39;a&#39;) as outfile:
                lines = infile.readlines()
                for z, line in enumerate(lines):
                    if line.startswith(r&#34;#DATA &#34;):
                        if lines[z + 2].startswith(r&#34;#+&#34;):
                            if lines[z + 4].startswith(r&#34;#+&#34;):
                                if lines[z + 6].startswith(r&#34;#+&#34;):
                                    outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+6].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                                else:
                                    outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                            else:
                                outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                        else:
                            outfile.write(line)
        logging.info(&#34;DATA POINTS: Finished. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;data_points_per_experiment_refined.txt&#34;)))
        return None
    else:
        logging.error(&#34;DATA POINTS:  No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="nucml.exfor.parsing_utilities.csv_creator"><code class="name flex">
<span>def <span class="ident">csv_creator</span></span>(<span>heavy_path, tmp_path, mode, ame_dir='C:\\Users\\Pedro\\Desktop\\AME', append_ame=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates files containing all extracted features generated when using the get_all() function.
The following CSV files are created:</p>
<ul>
<li>EXFOR_mode_ORIGINAL.csv: Contains the EXFOR database in it's original state.</li>
<li>EXFOR_mode_ORIGINAL_w_AME.csv: Contains the same features as in the original CSV
file plus AME data appended to each row. The appended AME is the original data therefore
not containing natural element data.</li>
<li>EXFOR_mode_MF3_AME_no_RawNan: is a dataset created for personal use. It contains no
missing values in both the EXFOR and the AME data entries. Furthermore, it is limited to
reaction data rows (MF=3). </li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>heavy_path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to directory where heavy files are to be saved.</dd>
<dt><strong><code>tmp_path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to directory where temporary files are to be saved.</dd>
<dt><strong><code>ame_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>path to directory where proccessed AME files are saved.</dd>
<dt><strong><code>append_ame</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, the AME data will be appended to the final EXFOR CSV.</dd>
<dt><strong><code>fillna</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, an additional CSV file .</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def csv_creator(heavy_path, tmp_path, mode, ame_dir=ame_dir_path, append_ame=True):
    &#34;&#34;&#34;Creates files containing all extracted features generated when using the get_all() function.
    The following CSV files are created:

    - EXFOR_mode_ORIGINAL.csv: Contains the EXFOR database in it&#39;s original state.
    - EXFOR_mode_ORIGINAL_w_AME.csv: Contains the same features as in the original CSV
        file plus AME data appended to each row. The appended AME is the original data therefore
        not containing natural element data.
    - EXFOR_mode_MF3_AME_no_RawNan: is a dataset created for personal use. It contains no
        missing values in both the EXFOR and the AME data entries. Furthermore, it is limited to 
        reaction data rows (MF=3). 

    Args:
        heavy_path (str): path to directory where heavy files are to be saved.
        tmp_path (str): path to directory where temporary files are to be saved.
        ame_dir (str): path to directory where proccessed AME files are saved.
        append_ame (bool): if True, the AME data will be appended to the final EXFOR CSV.
        fillna (bool): if True, an additional CSV file .

    Returns:
        None

    &#34;&#34;&#34;
    logging.info(&#34;EXFOR CSV: Reading data points from {}/all_cross_sections_v1.txt file into a DataFrame...&#34;.format(heavy_path))
    colnames = [&#34;Projectile&#34;, &#34;Target_ZA&#34;, &#34;Target_Metastable_State&#34;, &#34;MF&#34;, &#34;MT&#34;, &#34;Product_Metastable_State&#34;, \
                &#34;EXFOR_Status&#34;, &#34;Center_of_Mass_Flag&#34;, &#34;Energy&#34;,  &#34;dEnergy&#34;,  &#34;Data&#34;, &#34;dData&#34;,   &#34;Cos/LO&#34;,   &#34;dCos/LO&#34;, \
                &#34;ELV/HL&#34;,  &#34;dELV/HL&#34;, &#34;I78&#34;, &#34;Short_Reference&#34;, &#34;EXFOR_Accession_Number&#34;, &#34;EXFOR_SubAccession_Number&#34;, \
                &#34;EXFOR_Pointer&#34;]
    df = pd.read_csv(os.path.join(heavy_path, &#34;all_cross_sections_v1.txt&#34;), names=colnames, header=None, index_col=False, sep=&#34;;&#34;)

    ########################################################################################################
    ########################### FORMATTING CATEGORICAL AND STRING DATA #####################################
    ########################################################################################################

    logging.info(&#34;EXFOR CSV: Formatting data (this may take a couple minutes)...&#34;)
    # make string version of original column
    df[&#39;Target_ZA&#39;] = df[&#39;Target_ZA&#39;].astype(str)

    # Making Sure all rows have the same number of values
    max_length = 5
    df.Target_ZA = df.Target_ZA.apply(lambda x: &#39;0&#39;*(max_length - len(x)) + x)

    # Target feature is formated as ZZAAA
    df[&#39;Z&#39;] = df[&#39;Target_ZA&#39;].str[0:2].astype(int).fillna(0)
    df[&#39;A&#39;] = df[&#39;Target_ZA&#39;].str[2:5].astype(int).fillna(0)

    # Calculating number of neutrons = mass number - protons
    df[&#39;N&#39;] = df[&#39;A&#39;] - df[&#34;Z&#34;]

    metastate_dict = {&#34; &#34;: &#34;All_or_Total&#34;, &#34;G&#34;: &#34;Ground&#34;, &#34;1&#34;: &#34;M1&#34;, &#34;2&#34;: &#34;M2&#34;, &#34;3&#34;: &#34;M3&#34;, &#34;4&#34;: &#34;M4&#34;, 
                    &#34;5&#34;: &#34;M5&#34;, &#34;?&#34;: &#34;Unknown&#34;, &#34;+&#34;: &#34;More_than_1&#34;, &#34;T&#34;: &#34;All_or_Total&#34;}
    df = df.replace({&#34;Target_Metastable_State&#34;: metastate_dict, &#34;Product_Metastable_State&#34;: metastate_dict})

    exfor_status_dict = {&#34;U&#34;:&#34;Un_normalized&#34;, &#34;A&#34;:&#34;Approved_by_Author&#34;, &#34;C&#34;:&#34;Correlated&#34;, &#34;D&#34;:&#34;Dependent&#34;, 
                     &#34;O&#34;:&#34;Outdated&#34;, &#34;P&#34;:&#34;Preliminary&#34;, &#34;R&#34;:&#34;Re_normalized&#34;, &#34;S&#34;:&#34;Superseded&#34;, &#34; &#34;:&#34;Other&#34;}
    df = df.replace({&#34;EXFOR_Status&#34;: exfor_status_dict})

    df = df.replace({&#34;Center_of_Mass_Flag&#34;: {&#34;C&#34;:&#34;Center_of_Mass&#34;, &#34; &#34;:&#34;Lab&#34;}})


    ########################################################################################################
    ################################### FORMATTING NUMERICAL DATA ##########################################
    ########################################################################################################
    # Defining Numerical Columns to Fix and casting them as strings
    cols = [&#34;Energy&#34;, &#34;dEnergy&#34;, &#34;Data&#34;, &#34;dData&#34;, &#34;Cos/LO&#34;, &#34;dCos/LO&#34;, &#34;ELV/HL&#34;, &#34;dELV/HL&#34;]
    df[cols] = df[cols].astype(str)

    # df[cols] = df[cols].replace(to_replace=&#34;         &#34;, value=&#34;0.0000000&#34;)
    df[cols] = df[cols].replace(to_replace=&#34;         &#34;, value=np.nan)

    # We now strip values that may contain quatation marks and starting and trailing spaces
    for col in cols:
        df[col] = df[col].str.strip(&#34;\&#34;&#34;)
        df[col] = df[col].str.strip()

    # df[cols] = df[cols].replace(to_replace=&#34;&#34;, value=&#34;0.0000000&#34;)
    df[cols] = df[cols].replace(to_replace=&#34;&#34;, value=np.nan)

    # For the numerical values we know per formatting that each of them should be 9 characters in length
    max_length = 9

    for col in cols:
        df[col] = df[col].apply(lambda x: x if pd.isnull(x) else &#39; &#39;*(max_length - len(x)) + x)

    # Add appropiate formating for python to recognize it as numerical
    for col in cols:
        new_col = []
        values = df[col].values
        for x in values:
            if pd.isnull(x):
                new_col.append(x)
            elif &#34;+&#34; == x[7]:
                y = x[0:7]
                z = x[7:]
                new_col.append(y + &#34;E&#34; + z)
            elif &#34;+&#34; == x[6]:
                y = x[0:6]
                z = x[6:]
                new_col.append(y + &#34;E&#34; + z)
            elif &#34;-&#34; == x[7]:
                y = x[0:7]
                z = x[7:]
                new_col.append(y + &#34;E&#34; + z)
            elif &#34;-&#34; == x[6]:
                y = x[0:6]
                z = x[6:]
                new_col.append(y + &#34;E&#34; + z)
            else:
                new_col.append(x)
        df[col] = new_col

    # We now convert the columns to numerical
    for col in cols:
        df[col] = df[col].astype(float)
        logging.info(&#34;EXFOR CSV: Finished converting {} to float.&#34;.format(col))

    cat_cols = [&#34;Target_Metastable_State&#34;, &#34;MF&#34;, &#34;MT&#34;, &#34;I78&#34;, &#34;Product_Metastable_State&#34;, &#34;Center_of_Mass_Flag&#34;]

    # Convering all columns to strings and stripping whitespace
    for col in cat_cols:
        df[col] = df[col].astype(str)
        df[col] = df[col].str.strip(&#34;\&#34;&#34;)
        df[col] = df[col].str.strip()

    # Replace empty values in I78 for L representing Low
    df = df.replace({&#34;I78&#34;: {&#34;E2&#34;:&#34;Secondary_Energy&#34;, &#34;LVL&#34;:&#34;Level&#34;, &#34;HL&#34;:&#34;Half_Life&#34;, &#34;DLV&#34;:&#34;Level_Range&#34;, 
                         &#34;EXC&#34;:&#34;Excitation&#34;, &#34;DE2&#34;:&#34;Secondary_Energy_Range&#34;, &#34;MIN&#34;:&#34;Minimum_Energy&#34;, 
                         &#34;MAX&#34;:&#34;Maximum_Energy&#34;, &#34;&#34;:&#34;Other&#34;}})

    df.drop(columns=[&#39;Target_ZA&#39;], inplace=True)

    ########################################################################################################
    ################################# APPENDING OTHER INFORMATION ##########################################
    ########################################################################################################

    logging.info(&#34;EXFOR CSV: Reading .txt files from {} into DataFrames...&#34;.format(tmp_path))
    # Reading experiments reaction notation
    df1 = pd.read_csv(os.path.join(tmp_path, &#34;reaction_notations.txt&#34;), delim_whitespace=True, header=None)
    df1.columns = [&#34;Reaction&#34;, &#34;Reaction_Notation&#34;]

    # Reading Experiment Titles
    df2 = pd.read_csv(os.path.join(tmp_path, &#34;titles.txt&#34;), sep=&#34;#TITLE      &#34;, header=None, engine=&#34;python&#34;)
    df2.columns = [&#34;Keyword&#34;, &#34;Title&#34;]

    # Reading Data Points per Experiment
    df3 = pd.read_csv(os.path.join(tmp_path, &#34;data_points_per_experiment_refined.txt&#34;),  delim_whitespace=True, header=None)
    df3.columns = [&#34;Data&#34;, &#34;Multiple&#34;]

    # Reading Experiment Year
    df4 = pd.read_csv(os.path.join(tmp_path, &#34;years.txt&#34;), delim_whitespace=True, header=None)
    df4.columns = [&#34;Keyword&#34;, &#34;Year&#34;]

    # Reading Experiment Date
    df5 = pd.read_csv(os.path.join(tmp_path, &#34;authors.txt&#34;), sep=&#34;    &#34;, header=None, engine=&#34;python&#34;)
    df5.columns = [&#34;Keyword&#34;, &#34;Author&#34;]

    # Reading Experiment Institute
    df6 = pd.read_csv(os.path.join(tmp_path, &#34;institutes.txt&#34;), sep=&#34;  &#34;, header=None, engine=&#34;python&#34;)
    df6.columns = [&#34;Keyword&#34;, &#34;Institute&#34;]

    # Reading Experiment Year
    df7 = pd.read_csv(os.path.join(tmp_path, &#34;dates.txt&#34;), delim_whitespace=True, header=None)
    df7.columns = [&#34;Keyword&#34;, &#34;Date&#34;]

    # Reading Experiment Refere
    df8 = pd.read_csv(os.path.join(tmp_path, &#34;references.txt&#34;), sep=&#34;#REFERENCE  &#34;, header=None, engine=&#34;python&#34;)
    df8.columns = [&#34;Keyword&#34;, &#34;Reference&#34;]

    # Reading Dataset Number
    df9 = pd.read_csv(os.path.join(tmp_path, &#34;dataset_num.txt&#34;), sep=&#34;#DATASET    &#34;, header=None, engine=&#34;python&#34;)
    df9.columns = [&#34;Keyword&#34;, &#34;Dataset_Number&#34;]

    # Reading EXFOR entry number
    df10 = pd.read_csv(os.path.join(tmp_path, &#34;entry.txt&#34;), sep=&#34;#ENTRY      &#34;, header=None, engine=&#34;python&#34;)
    df10.columns = [&#34;Keyword&#34;, &#34;EXFOR_Entry&#34;]

    # Reading reference code
    df11 = pd.read_csv(os.path.join(tmp_path, &#34;refcode.txt&#34;), sep=&#34;#REF-CODE   &#34;, header=None, engine=&#34;python&#34;)
    df11.columns = [&#34;Keyword&#34;, &#34;Reference_Code&#34;]


    # Merging Datapoints, notation and titles and expanding based on datapoints
    logging.info(&#34;EXFOR CSV: Expanding information based on the number of datapoints per experimental campaign...&#34;)
    pre_final = pd.concat([df3, df1, df2, df4, df5, df6, df7, df8, df9, df10, df11], axis=1)
    final = pre_final.reindex(pre_final.index.repeat(pre_final.Multiple))
    final[&#39;position&#39;] = final.groupby(level=0).cumcount() + 1
    
    # Indexing only required information and saving file
    final = final[[&#34;Reaction_Notation&#34;, &#34;Title&#34;, &#34;Year&#34;, &#34;Author&#34;, &#34;Institute&#34;, &#34;Date&#34;, &#34;Reference&#34;, 
                &#34;Dataset_Number&#34;, &#34;EXFOR_Entry&#34;, &#34;Reference_Code&#34;]]

    # Reset Indexes to make copying faster
    df = df.reset_index(drop=True)
    final = final.reset_index(drop=True)

    logging.info(&#34;EXFOR CSV: Appending information to main DataFrame...&#34;)
    # Assign newly extracted data to main dataframe
    df[&#34;Reaction_Notation&#34;] = final[&#34;Reaction_Notation&#34;]
    df[&#34;Title&#34;] = final[&#34;Title&#34;]
    df[&#34;Year&#34;] = final[&#34;Year&#34;]
    df[&#34;Author&#34;] = final[&#34;Author&#34;]
    df[&#34;Institute&#34;] = final[&#34;Institute&#34;]
    df[&#34;Date&#34;] = final[&#34;Date&#34;]
    df[&#34;Reference&#34;] = final[&#34;Reference&#34;]
    df[&#34;Dataset_Number&#34;] = final[&#34;Dataset_Number&#34;]
    df[&#34;EXFOR_Entry&#34;] = final[&#34;EXFOR_Entry&#34;]
    df[&#34;Reference_Code&#34;] = final[&#34;Reference_Code&#34;]

    df.Title = df.Title.fillna(&#34;No Title Found. Check EXFOR.&#34;)
    df.Reference = df.Reference.fillna(&#34;No Reference Found. Check EXFOR.&#34;)
    df.Short_Reference = df.Short_Reference.fillna(&#34;No Reference Found. Check EXFOR.&#34;)
    df.Reference_Code = df.Reference_Code.fillna(&#34;No Reference Code Found. Check EXFOR.&#34;)
    df.Author = df.Author.fillna(&#34;No Author Found. Check EXFOR.&#34;)
    df.EXFOR_Pointer = df.EXFOR_Pointer.fillna(&#34;No Pointer&#34;)

    df.EXFOR_Pointer = df.EXFOR_Pointer.apply(lambda x: str(int(x)) if isinstance(x, numbers.Number) else x)
    df.Date = df.Date.apply(lambda x: str(x)[:4] + &#34;/&#34; + str(x)[4:6] + &#34;/&#34; + str(x)[6:])
    df.EXFOR_SubAccession_Number = df.EXFOR_SubAccession_Number.astype(int)
    df.Institute = df.Institute.apply(lambda x: x.replace(&#34;(&#34;, &#34;&#34;).replace(&#34;)&#34;, &#34;&#34;))

    df = df.replace({&#39;Projectile&#39;: {1: &#34;neutron&#34;, 1001: &#34;proton&#34;, 2003:&#34;helion&#34;, 0:&#34;gamma&#34;, 1002:&#34;deuteron&#34;, 2004:&#34;alpha&#34;}})

    if df.Projectile.unique()[0] == &#34;neutron&#34;:
        Projectile_Z, Projectile_A, Projectile_N = 0, 1, 1
    elif df.Projectile.unique()[0] == &#34;proton&#34;:
        Projectile_Z, Projectile_A, Projectile_N = 1, 1, 0
    elif df.Projectile.unique()[0] == &#34;helion&#34;:
        Projectile_Z, Projectile_A, Projectile_N = 2, 3, 1
    elif df.Projectile.unique()[0] == &#34;gamma&#34;:
        Projectile_Z, Projectile_A, Projectile_N = 0, 0, 0
    elif df.Projectile.unique()[0] == &#34;deuteron&#34;:
        Projectile_Z, Projectile_A, Projectile_N = 1, 2, 1
    elif df.Projectile.unique()[0] == &#34;alpha&#34;:
        Projectile_Z, Projectile_A, Projectile_N = 2, 4, 2
    df[&#34;Projectile_Z&#34;] = Projectile_Z
    df[&#34;Projectile_A&#34;] = Projectile_A
    df[&#34;Projectile_N&#34;] = Projectile_N

    element_w_a = objects.load_zan()
    element_w_a = pd.DataFrame.from_dict(element_w_a, orient=&#39;index&#39;)
    # There are no molecular
    element_w_a.loc[&#39;12019&#39;] = [&#39;Heavy Water&#39;, 19, 1, 20, &#34;Heavy Water&#34;]

    df = df.merge(element_w_a, on=[&#39;N&#39;, &#39;Z&#39;, &#39;A&#39;], how=&#39;left&#39;)

    df[[&#34;EXFOR_Accession_Number&#34;, &#34;Dataset_Number&#34;, &#34;EXFOR_Entry&#34;]]  = df[[&#34;EXFOR_Accession_Number&#34;, &#34;Dataset_Number&#34;, &#34;EXFOR_Entry&#34;]].astype(str)
    csv_name = os.path.join(heavy_path, &#34;EXFOR_&#34; + mode + &#34;_ORIGINAL.csv&#34;)
    logging.info(&#34;EXFOR CSV: Saving EXFOR CSV file to {}...&#34;.format(csv_name))
    df.to_csv(csv_name, index=False)

    if append_ame:
        logging.info(&#34;EXFOR CSV: Reading AME file...&#34;)
        df_workxs = df.copy()
        masses = pd.read_csv(ame_dir + &#34;AME_Natural_Properties_w_NaN.csv&#34;).rename(
            columns={&#39;N&#39;: &#39;Neutrons&#39;, &#39;A&#39;: &#39;Mass_Number&#39;, &#39;Neutrons&#39;:&#39;N&#39;, &#39;Mass_Number&#39;:&#39;A&#39;, &#39;Flag&#39;:&#39;Element_Flag&#39;})
        df_workxs = df_workxs.reset_index(drop=True)
        masses = masses.reset_index(drop=True)
        logging.info(&#34;EXFOR CSV: Appending AME data to EXFOR File...&#34;)
        df = df_workxs.merge(masses, on=[&#39;N&#39;, &#39;Z&#39;], how=&#39;left&#39;)
        df = df.drop(columns=[&#34;A_x&#34;, &#34;A_y&#34;, &#34;N&#34;, &#34;EL&#34;]).rename(columns={&#39;Neutrons&#39;: &#39;N&#39;, &#39;Mass_Number&#39;:&#39;A&#39;})
        df = df[~df[&#39;N&#39;].isnull()]
        df[[&#34;N&#34;, &#34;A&#34;]] = df[[&#34;N&#34;, &#34;A&#34;]].astype(int)
        csv_name = os.path.join(heavy_path, &#34;EXFOR_&#34; + mode + &#34;_ORIGINAL_w_AME.csv&#34;)
        logging.info(&#34;EXFOR CSV: Saving EXFOR CSV file to {}...&#34;.format(csv_name))
        df.to_csv(csv_name, index=False)
    return None</code></pre>
</details>
</dd>
<dt id="nucml.exfor.parsing_utilities.get_all"><code class="name flex">
<span>def <span class="ident">get_all</span></span>(<span>c4_list, heavy_path, tmp_path, mode='neutrons')</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves all avaliable information from all .c4 files. This function combines the
proccesses defined on:</p>
<ul>
<li>get_c4_names()</li>
<li>get_raw_datapoints()</li>
<li>get_authors()</li>
<li>get_years()</li>
<li>get_institutes()</li>
<li>get_dates()</li>
<li>get_titles()</li>
<li>get_references()</li>
<li>get_reaction_notation()</li>
<li>get_datapoints_per_experiment()</li>
</ul>
<p>It is optimized to run faster than running the individual functions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c4_list</code></strong> :&ensp;<code>list</code></dt>
<dd>iterable containing the paths to c4 files.</dd>
<dt><strong><code>heavy_path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to directory where heavy files are to be saved.</dd>
<dt><strong><code>tmp_path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to directory where temporary files are to be saved.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all(c4_list, heavy_path, tmp_path, mode=&#34;neutrons&#34;):
    &#34;&#34;&#34;Retrieves all avaliable information from all .c4 files. This function combines the
    proccesses defined on:

    - get_c4_names()
    - get_raw_datapoints()
    - get_authors()
    - get_years()
    - get_institutes()
    - get_dates()
    - get_titles()
    - get_references()
    - get_reaction_notation()
    - get_datapoints_per_experiment()

    It is optimized to run faster than running the individual functions.

    Args:
        c4_list (list): iterable containing the paths to c4 files.
        heavy_path (str): path to directory where heavy files are to be saved.
        tmp_path (str): path to directory where temporary files are to be saved.

    Returns:
        None

    &#34;&#34;&#34;

    if len(c4_list) != 0:
        # This will be appended to the previous directories
        tmp_path = os.path.join(tmp_path, &#34;Extracted_Text_&#34; + mode + &#34;/&#34;)
        heavy_path = os.path.join(heavy_path, &#34;EXFOR_&#34; + mode + &#34;/&#34;)
        general_utilities.initialize_directories_v2(tmp_path, reset=True)
        general_utilities.initialize_directories_v2(heavy_path, reset=True)


        cross_section_file = os.path.join(heavy_path, &#34;all_cross_sections.txt&#34;)
        if os.path.exists(cross_section_file):
            os.remove(cross_section_file)

        logging.info(&#34;EXFOR: Extracting experimental data, authors, years, institutes, and dates...&#34;)
        for i in c4_list:
            with open(i) as infile, \
                open(os.path.join(heavy_path, &#34;all_cross_sections.txt&#34;), &#39;a&#39;) as num_data, \
                open(os.path.join(tmp_path, &#39;authors.txt&#39;), &#39;a&#39;) as authors, \
                open(os.path.join(tmp_path, &#39;years.txt&#39;), &#39;a&#39;) as years, \
                open(os.path.join(tmp_path, &#39;institutes.txt&#39;), &#39;a&#39;) as institute, \
                open(os.path.join(tmp_path, &#39;entry.txt&#39;), &#39;a&#39;) as entry, \
                open(os.path.join(tmp_path, &#39;refcode.txt&#39;), &#39;a&#39;) as refcode, \
                open(os.path.join(tmp_path, &#39;dataset_num.txt&#39;), &#39;a&#39;) as dataset_num, \
                open(os.path.join(tmp_path, &#39;dates.txt&#39;), &#39;a&#39;) as date:
                copy = False
                for line in infile:
                    if line.startswith(r&#34;#AUTHOR1&#34;):
                        copy=False
                        authors.write(line)
                    elif line.startswith(r&#34;#YEAR&#34;):
                        copy=False
                        years.write(line)
                    elif line.startswith(r&#39;#ENTRY&#39;):
                        copy=False
                        entry.write(line)
                    elif line.startswith(r&#39;#REF-CODE&#39;):
                        copy=False
                        refcode.write(line)
                    elif line.startswith(r&#39;#DATASET&#39;):
                        if len(line) &gt; 16:
                            copy=False
                            dataset_num.write(line)                    
                    elif line.startswith(r&#34;#INSTITUTE&#34;):
                        copy=False
                        institute.write(line)
                    elif line.startswith(r&#34;#DATE&#34;):
                        copy=False
                        date.write(line)
                    elif line.startswith(r&#34;#---&gt;&lt;----&gt;o&lt;-&gt;&lt;--&gt;ooo&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-&gt;&lt;-----------------------&gt;&lt;---&gt;&lt;-&gt;o&#34;):
                        copy = True
                        continue
                    elif line.startswith(r&#34;#/DATA&#34;):
                        copy = False
                        continue
                    elif copy:
                        num_data.write(line)
                infile.close()
                authors.close()
                years.close()
                institute.close()
                date.close()
                num_data.close()
        logging.info(&#34;EXFOR: Finished extracting experimental data, authors, years, institutes, and dates.&#34;)
        logging.info(&#34;EXFOR: Extracting titles, references, and number of data points per experiment...&#34;)
        for i in c4_list:
            with open(i, &#34;r&#34;) as infile, \
                open(os.path.join(tmp_path, &#39;titles.txt&#39;), &#39;a&#39;) as titles, \
                open(os.path.join(tmp_path, &#39;references.txt&#39;), &#39;a&#39;) as references, \
                open(os.path.join(tmp_path, &#39;data_points_per_experiment_refined.txt&#39;), &#39;a&#39;) as data_points, \
                open(os.path.join(tmp_path, &#39;reaction_notations.txt&#39;), &#39;a&#39;) as reactions:
                lines = infile.readlines()
                for z, line in enumerate(lines):
                    if line.startswith(r&#34;#TITLE&#34;):
                        if lines[z + 2].startswith(r&#34;#+&#34;):
                            if lines[z + 4].startswith(r&#34;#+&#34;):
                                if lines[z + 6].startswith(r&#34;#+&#34;):
                                    titles.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+6].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                                else:
                                    titles.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                            else:
                                titles.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                        else:
                            titles.write(line)

                    elif line.startswith(r&#34;#REFERENCE&#34;):
                        if lines[z + 2].startswith(r&#34;#+&#34;):
                            if lines[z + 4].startswith(r&#34;#+&#34;):
                                if lines[z + 6].startswith(r&#34;#+&#34;):
                                    references.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+6].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                                else:
                                    references.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                            else:
                                references.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                        else:
                            references.write(line)

                    elif line.startswith(r&#34;#DATA &#34;):
                        if lines[z + 2].startswith(r&#34;#+&#34;):
                            if lines[z + 4].startswith(r&#34;#+&#34;):
                                if lines[z + 6].startswith(r&#34;#+&#34;):
                                    data_points.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+6].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                                else:
                                    data_points.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                            else:
                                data_points.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                        else:
                            data_points.write(line)


                    elif line.startswith(r&#34;#REACTION&#34;):
                        if lines[z + 2].startswith(r&#34;#+&#34;):
                            if lines[z + 4].startswith(r&#34;#+&#34;):
                                if lines[z + 6].startswith(r&#34;#+&#34;):
                                    reactions.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+6].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                                else:
                                    reactions.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                            else:
                                reactions.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                        else:
                            reactions.write(line)
                infile.close()
                titles.close()
                references.close()
                data_points.close()
                reactions.write(line)
        logging.info(&#34;EXFOR: Finished extracting titles, references, and number of data points per experiment.&#34;)
        logging.info(&#34;EXFOR: Formatting experimental data...&#34;)
        with open(cross_section_file) as infile, open(os.path.join(heavy_path, &#34;all_cross_sections_v1.txt&#34;), &#39;w&#39;) as outfile:
            for line in infile:
                if line.strip():
                    string = list(line)
                    # for i, j in enumerate([5, 11, 12, 15, 19, 22, 31, 40, 49, 58, 67, 76, 85, 94, 95, 122, 127]):
                    for i, j in enumerate([5, 11, 12, 15, 19, 20, 21, 22, 31, 40, 49, 58, 67, 76, 85, 94, 97, 122, 127, 130]):
                        string.insert(i + j, &#39;;&#39;)
                    outfile.write(&#34;&#34;.join(string))
        logging.info(&#34;EXFOR: Finished formating experimental data.&#34;)
        os.remove(cross_section_file)
        logging.info(&#34;EXFOR: Finished.&#34;)
        return None
    else:
        logging.error(&#34;EXFOR:  No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None</code></pre>
</details>
</dd>
<dt id="nucml.exfor.parsing_utilities.get_authors"><code class="name flex">
<span>def <span class="ident">get_authors</span></span>(<span>c4_list, saving_directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the avaliable Authors from all entries in all .c4 files.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c4_list</code></strong> :&ensp;<code>list</code></dt>
<dd>iterable containing the paths to all c4 files to be processed.</dd>
<dt><strong><code>saving_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to directory for saving files.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_authors(c4_list, saving_directory):
    &#34;&#34;&#34;Retrieves the avaliable Authors from all entries in all .c4 files.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files.

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        logging.info(&#34;AUTHORS: Extracting...&#34;)
        for i in c4_list:
            with open(i) as infile, open(os.path.join(saving_directory, &#39;authors.txt&#39;), &#39;a&#39;) as outfile:
                for line in infile:
                    if line.startswith(r&#34;#AUTHOR1&#34;):
                        outfile.write(line)
        logging.info(&#34;AUTHORS: Finished. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;authors.txt&#34;)))
        return None
    else:
        logging.error(&#34;AUTHORS: No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None</code></pre>
</details>
</dd>
<dt id="nucml.exfor.parsing_utilities.get_c4_names"><code class="name flex">
<span>def <span class="ident">get_c4_names</span></span>(<span>originals_directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Searches given directory for EXFOR-generated C4 files.
It returns a list of relative paths for each encountered file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>originals_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to the directory containing all .c4 files..</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>contains relative path to each encountered .c4 file. None if no files are found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_c4_names(originals_directory):
    &#34;&#34;&#34;Searches given directory for EXFOR-generated C4 files.  It returns a list of relative paths for each encountered file.

    Args:
        originals_directory (str): path to the directory containing all .c4 files..

    Returns:
        list: contains relative path to each encountered .c4 file. None if no files are found.
    &#34;&#34;&#34;
    logging.info(&#34;C4: Searching {} directory for .c4 files...&#34;.format(originals_directory))

    names = natsorted(general_utilities.get_files_w_extension(originals_directory, &#34;.c4&#34;))
    logging.info(&#34;C4: Finished. Found {} .c4 files.&#34;.format(len(names)))
    return names</code></pre>
</details>
</dd>
<dt id="nucml.exfor.parsing_utilities.get_datapoints_per_experiment"><code class="name flex">
<span>def <span class="ident">get_datapoints_per_experiment</span></span>(<span>c4_list, saving_directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the number of data points per experiment from all .c4 files.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c4_list</code></strong> :&ensp;<code>list</code></dt>
<dd>iterable containing the paths to all c4 files to be processed.</dd>
<dt><strong><code>saving_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to directory for saving files.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_datapoints_per_experiment(c4_list, saving_directory):
    &#34;&#34;&#34;Retrieves the number of data points per experiment from all .c4 files.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files.

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        logging.info(&#34;DATA POINTS: Extracting...&#34;)
        for i in c4_list:
            with open(i, &#34;r&#34;) as infile, open(os.path.join(saving_directory, &#39;data_points_per_experiment_refined.txt&#39;), &#39;a&#39;) as outfile:
                lines = infile.readlines()
                for z, line in enumerate(lines):
                    if line.startswith(r&#34;#DATA &#34;):
                        if lines[z + 2].startswith(r&#34;#+&#34;):
                            if lines[z + 4].startswith(r&#34;#+&#34;):
                                if lines[z + 6].startswith(r&#34;#+&#34;):
                                    outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+6].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                                else:
                                    outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                            else:
                                outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                        else:
                            outfile.write(line)
        logging.info(&#34;DATA POINTS: Finished. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;data_points_per_experiment_refined.txt&#34;)))
        return None
    else:
        logging.error(&#34;DATA POINTS:  No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None</code></pre>
</details>
</dd>
<dt id="nucml.exfor.parsing_utilities.get_dates"><code class="name flex">
<span>def <span class="ident">get_dates</span></span>(<span>c4_list, saving_directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the avaliable Dates from all .c4 files.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c4_list</code></strong> :&ensp;<code>list</code></dt>
<dd>iterable containing the paths to all c4 files to be processed.</dd>
<dt><strong><code>saving_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to directory for saving files.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dates(c4_list, saving_directory):
    &#34;&#34;&#34;Retrieves the avaliable Dates from all .c4 files.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files.

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        logging.info(&#34;DATES: Extracting...&#34;)
        for i in c4_list:
            with open(i) as infile, open(os.path.join(saving_directory, &#39;dates.txt&#39;), &#39;a&#39;) as outfile:
                for line in infile:
                    if line.startswith(r&#34;#DATE&#34;):
                        outfile.write(line)
        logging.info(&#34;DATES: Finished. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;dates.txt&#34;)))
        return None
    else:
        logging.error(&#34;DATES: No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None</code></pre>
</details>
</dd>
<dt id="nucml.exfor.parsing_utilities.get_institutes"><code class="name flex">
<span>def <span class="ident">get_institutes</span></span>(<span>c4_list, saving_directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the avaliable Institutes from all .c4 files.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c4_list</code></strong> :&ensp;<code>list</code></dt>
<dd>iterable containing the paths to all c4 files to be processed.</dd>
<dt><strong><code>saving_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to directory for saving files.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_institutes(c4_list, saving_directory):
    &#34;&#34;&#34;Retrieves the avaliable Institutes from all .c4 files.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files.

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        logging.info(&#34;INSTITUTES: Extracting...&#34;)
        for i in c4_list:
            with open(i) as infile, open(os.path.join(saving_directory, &#39;institutes.txt&#39;), &#39;a&#39;) as outfile:
                for line in infile:
                    if line.startswith(r&#34;#INSTITUTE&#34;):
                        outfile.write(line)
        logging.info(&#34;INSTITUTES: Finished. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;institutes.txt&#34;)))
        return None
    else:
        logging.error(&#34;INSTITUTES: No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None</code></pre>
</details>
</dd>
<dt id="nucml.exfor.parsing_utilities.get_raw_datapoints"><code class="name flex">
<span>def <span class="ident">get_raw_datapoints</span></span>(<span>c4_list, saving_directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Collects the data section of the c4 files into a single TXT file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c4_list</code></strong> :&ensp;<code>list</code></dt>
<dd>iterable containing the paths to all c4 files to be processed.</dd>
<dt><strong><code>saving_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to directory for saving files (needs to hold more than 6 GB of information).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_raw_datapoints(c4_list, saving_directory):
    &#34;&#34;&#34;Collects the data section of the c4 files into a single TXT file.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files (needs to hold more than 6 GB of information).

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        if os.path.exists(saving_directory + &#34;/all_cross_sections.txt&#34;):
            logging.info(&#34;RAW DATAPOINTS: An all_cross_sections.txt file already exists. Removing to create new file...&#34;)
            os.remove(os.path.join(saving_directory, &#34;/all_cross_sections.txt&#34;))

        logging.info(&#34;RAW DATAPOINTS: Processing {} .c4 files.&#34;.format(len(c4_list)))

        logging.info(&#34;RAW DATAPOINTS: Extracting experimental data from all .c4 EXFOR files...&#34;)
        for i in c4_list:
            with open(i) as infile, open(os.path.join(saving_directory, &#34;all_cross_sections.txt&#34;), &#39;a&#39;) as outfile:
                copy = False
                for line in infile:
                    if line.startswith(r&#34;#---&gt;&lt;----&gt;o&lt;-&gt;&lt;--&gt;ooo&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-------&gt;&lt;-&gt;&lt;-----------------------&gt;&lt;---&gt;&lt;-&gt;o&#34;):
                        copy = True
                        continue
                    elif line.startswith(r&#34;#/DATA&#34;):
                        copy = False
                        continue
                    elif copy:
                        outfile.write(line)
                infile.close()
                outfile.close()
        logging.info(&#34;RAW DATAPOINTS: Finished extracting all experimental data.&#34;)

        logging.info(&#34;RAW DATAPOINTS: Formatting extracted data using EXFORs fortran format...&#34;)
        with open(os.path.join(saving_directory, &#34;all_cross_sections.txt&#34;)) as infile, open(os.path.join(saving_directory, &#34;all_cross_sections_v1.txt&#34;), &#39;w&#39;) as outfile:
            for line in infile:
                if line.strip():
                    string = list(line)
                    for i, j in enumerate([5, 11, 12, 15, 19, 22, 31, 40, 49, 58, 67, 76, 85, 94, 95, 122, 127]):
                        string.insert(i + j, &#39;;&#39;)
                    outfile.write(&#34;&#34;.join(string))
        logging.info(&#34;RAW DATAPOINTS: Finished formating EXFOR data. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;all_cross_sections_v1.txt&#34;)))
        os.remove(os.path.join(saving_directory + &#34;all_cross_sections.txt&#34;))
        return None
    else:
        logging.error(&#34;RAW DATAPOINTS: No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None</code></pre>
</details>
</dd>
<dt id="nucml.exfor.parsing_utilities.get_reaction_notations"><code class="name flex">
<span>def <span class="ident">get_reaction_notations</span></span>(<span>c4_list, saving_directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the avaliable reaction notation from all .c4 files.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c4_list</code></strong> :&ensp;<code>list</code></dt>
<dd>iterable containing the paths to all c4 files to be processed.</dd>
<dt><strong><code>saving_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to directory for saving files.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reaction_notations(c4_list, saving_directory):
    &#34;&#34;&#34;Retrieves the avaliable reaction notation from all .c4 files.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files.

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        logging.info(&#34;REACTION NOTATION: Extracting...&#34;)
        for i in c4_list:
            with open(i, &#34;r&#34;) as infile, open(os.path.join(saving_directory, &#39;reaction_notations.txt&#39;), &#39;a&#39;) as outfile:
                lines = infile.readlines()
                for z, line in enumerate(lines):
                    if line.startswith(r&#34;#REACTION&#34;):
                        if lines[z + 2].startswith(r&#34;#+&#34;):
                            if lines[z + 4].startswith(r&#34;#+&#34;):
                                if lines[z + 6].startswith(r&#34;#+&#34;):
                                    outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+6].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                                else:
                                    outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                            else:
                                outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                        else:
                            outfile.write(line)
        logging.info(&#34;REACTION NOTATION: Finished. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;reaction_notation.txt&#34;)))
        return None
    else:
        logging.error(&#34;REACTION NOTATION: No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None</code></pre>
</details>
</dd>
<dt id="nucml.exfor.parsing_utilities.get_references"><code class="name flex">
<span>def <span class="ident">get_references</span></span>(<span>c4_list, saving_directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the avaliable references for all experiments from all .c4 files.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c4_list</code></strong> :&ensp;<code>list</code></dt>
<dd>iterable containing the paths to all c4 files to be processed.</dd>
<dt><strong><code>saving_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to directory for saving files.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_references(c4_list, saving_directory):
    &#34;&#34;&#34;Retrieves the avaliable references for all experiments from all .c4 files.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files.

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        logging.info(&#34;REFERENCES: Extracting...&#34;)
        for i in c4_list:
            with open(i, &#34;r&#34;) as infile, open(os.path.join(saving_directory, &#39;references.txt&#39;), &#39;a&#39;) as outfile:
                lines = infile.readlines()
                for z, line in enumerate(lines):
                    if line.startswith(r&#34;#REFERENCE&#34;):
                        if lines[z + 2].startswith(r&#34;#+&#34;):
                            if lines[z + 4].startswith(r&#34;#+&#34;):
                                if lines[z + 6].startswith(r&#34;#+&#34;):
                                    outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+6].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                                else:
                                    outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                            else:
                                outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                        else:
                            outfile.write(line)
        logging.info(&#34;REFERENCES: Finished. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;references.txt&#34;)))
        return None
    else:
        logging.error(&#34;REFERENCES: No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None</code></pre>
</details>
</dd>
<dt id="nucml.exfor.parsing_utilities.get_titles"><code class="name flex">
<span>def <span class="ident">get_titles</span></span>(<span>c4_list, saving_directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the avaliable experiment Titles from all .c4 files.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c4_list</code></strong> :&ensp;<code>list</code></dt>
<dd>iterable containing the paths to all c4 files to be processed.</dd>
<dt><strong><code>saving_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to directory for saving files.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_titles(c4_list, saving_directory):
    &#34;&#34;&#34;Retrieves the avaliable experiment Titles from all .c4 files.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files.

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        logging.info(&#34;TITLES: Extracting...&#34;)
        for i in c4_list:
            with open(i, &#34;r&#34;) as infile, open(os.path.join(saving_directory, &#39;titles.txt&#39;), &#39;a&#39;) as outfile:
                lines = infile.readlines()
                for z, line in enumerate(lines):
                    if line.startswith(r&#34;#TITLE&#34;):
                        if lines[z + 2].startswith(r&#34;#+&#34;):
                            if lines[z + 4].startswith(r&#34;#+&#34;):
                                if lines[z + 6].startswith(r&#34;#+&#34;):
                                    outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+6].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                                else:
                                    outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34; &#34; +
                                                str(lines[z+4].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                            else:
                                outfile.write(str(line.strip(&#39;\n&#39;)) + &#34; &#34; + str(lines[z+2].strip(&#39;#+&#39;).strip()) + &#34;\n&#34;)
                        else:
                            outfile.write(line)
        logging.info(&#34;TITLES: Finished. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;titles.txt&#34;)))
        return None
    else:
        logging.error(&#34;TITLES: No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None</code></pre>
</details>
</dd>
<dt id="nucml.exfor.parsing_utilities.get_years"><code class="name flex">
<span>def <span class="ident">get_years</span></span>(<span>c4_list, saving_directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the years from from all .c4 exfor entries.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c4_list</code></strong> :&ensp;<code>list</code></dt>
<dd>iterable containing the paths to all c4 files to be processed.</dd>
<dt><strong><code>saving_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>path to directory for saving files.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_years(c4_list, saving_directory):
    &#34;&#34;&#34;Retrieves the years from from all .c4 exfor entries.

    Args:
        c4_list (list): iterable containing the paths to all c4 files to be processed.
        saving_directory (str): path to directory for saving files.

    Returns:
        None

    &#34;&#34;&#34;
    if len(c4_list) != 0:
        logging.info(&#34;YEARS: Extracting...&#34;)
        for i in c4_list:
            with open(i) as infile, open(os.path.join(saving_directory, &#39;years.txt&#39;), &#39;a&#39;) as outfile:
                for line in infile:
                    if line.startswith(r&#34;#YEAR&#34;):
                        outfile.write(line)
        logging.info(&#34;YEARS: Finished. Saved to {}&#34;.format(os.path.join(saving_directory, &#34;years.txt&#34;)))
        return None
    else:
        logging.error(&#34;YEARS: No .c4 files found. Make sure you specified the path correctly.&#34;)
        sys.exit()
        return None</code></pre>
</details>
</dd>
<dt id="nucml.exfor.parsing_utilities.impute_original_exfor"><code class="name flex">
<span>def <span class="ident">impute_original_exfor</span></span>(<span>heavy_path, tmp_path, mode, ame_dir='C:\\Users\\Pedro\\Desktop\\AME', append_ame=True, MF_number='3')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def impute_original_exfor(heavy_path, tmp_path, mode, ame_dir=ame_dir_path, append_ame=True, MF_number=&#34;3&#34;):
    csv_name = os.path.join(heavy_path, &#34;EXFOR_&#34; + mode + &#34;_ORIGINAL.csv&#34;)
    df = pd.read_csv(csv_name)

    if append_ame:
        logging.info(&#34;EXFOR CSV: Reading AME file...&#34;)
        df_workxs = df.copy()
        masses = pd.read_csv(ame_dir + &#34;AME_Natural_Properties_no_NaN.csv&#34;).rename(
            columns={&#39;N&#39;: &#39;Neutrons&#39;, &#39;A&#39;: &#39;Mass_Number&#39;, &#39;Neutrons&#39;:&#39;N&#39;, &#39;Mass_Number&#39;:&#39;A&#39;, &#39;Flag&#39;:&#39;Element_Flag&#39;})

        df_workxs = df_workxs.reset_index(drop=True)
        masses = masses.reset_index(drop=True)
        logging.info(&#34;EXFOR CSV: Appending AME data to EXFOR File...&#34;)
        df = df_workxs.merge(masses, on=[&#39;N&#39;, &#39;Z&#39;], how=&#39;left&#39;)
        df = df.drop(columns=[&#34;A_x&#34;, &#34;A_y&#34;, &#34;N&#34;, &#34;EL&#34;]).rename(columns={&#39;Neutrons&#39;: &#39;N&#39;, &#39;Mass_Number&#39;:&#39;A&#39;})
        df = df[~df[&#39;N&#39;].isnull()]
        df[[&#34;N&#34;, &#34;A&#34;]] = df[[&#34;N&#34;, &#34;A&#34;]].astype(int)
        df[&#34;O&#34;].fillna(value=&#34;Other&#34;, inplace=True)

    logging.info(&#34;EXFOR CSV: Creating new CSV file with only MF=3 data...&#34;)
    df.MF = df.MF.astype(str)
    df.MT = df.MT.astype(str)
    df = df[df[&#34;MF&#34;] == MF_number]

    # We get rid of heavy water measurments
    if MF_number == &#34;3&#34;:
        logging.info(&#34;...&#34;)

    columns_drop = [&#34;MF&#34;, &#34;Cos/LO&#34;, &#34;dCos/LO&#34;]
    df = df.drop(columns=columns_drop)

    logging.info(&#34;EXFOR CSV: Filling dEnergy, dData, and dELV by reaction channel...&#34;)
    df[&#34;Uncertainty_E&#34;] = df[&#34;dEnergy&#34;]/df[&#34;Energy&#34;]
    df[&#34;Uncertainty_D&#34;] = df[&#34;dData&#34;]/df[&#34;Data&#34;]
    df[&#34;Uncertainty_ELV&#34;] = df[&#34;dELV/HL&#34;]/df[&#34;ELV/HL&#34;]

    df[&#34;Uncertainty_E&#34;] = df[[&#34;MT&#34;, &#34;Uncertainty_E&#34;]].groupby(&#34;MT&#34;).transform(lambda x: x.fillna(x.mean()))
    df[&#34;Uncertainty_D&#34;] = df[[&#34;MT&#34;, &#34;Uncertainty_D&#34;]].groupby(&#34;MT&#34;).transform(lambda x: x.fillna(x.mean()))
    df[&#34;Uncertainty_ELV&#34;] = df[[&#34;MT&#34;, &#34;Uncertainty_ELV&#34;]].groupby(&#34;MT&#34;).transform(lambda x: x.fillna(x.mean()))

    logging.info(&#34;EXFOR CSV: Filling dEnergy, dData, and dELV by Institute...&#34;)
    df[&#34;Uncertainty_E&#34;] = df[[&#34;Institute&#34;, &#34;Uncertainty_E&#34;]].groupby(&#34;Institute&#34;).transform(lambda x: x.fillna(x.mean()))
    df[&#34;Uncertainty_D&#34;] = df[[&#34;Institute&#34;, &#34;Uncertainty_D&#34;]].groupby(&#34;Institute&#34;).transform(lambda x: x.fillna(x.mean()))
    df[&#34;Uncertainty_ELV&#34;] = df[[&#34;Institute&#34;, &#34;Uncertainty_ELV&#34;]].groupby(&#34;Institute&#34;).transform(lambda x: x.fillna(x.mean()))

    logging.info(&#34;EXFOR CSV: Filling dEnergy, dData, and dELV by Isotope...&#34;)
    df[&#34;Uncertainty_E&#34;] = df[[&#34;Isotope&#34;, &#34;Uncertainty_E&#34;]].groupby(&#34;Isotope&#34;).transform(lambda x: x.fillna(x.mean()))
    df[&#34;Uncertainty_D&#34;] = df[[&#34;Isotope&#34;, &#34;Uncertainty_D&#34;]].groupby(&#34;Isotope&#34;).transform(lambda x: x.fillna(x.mean()))
    df[&#34;Uncertainty_ELV&#34;] = df[[&#34;Isotope&#34;, &#34;Uncertainty_ELV&#34;]].groupby(&#34;Isotope&#34;).transform(lambda x: x.fillna(x.mean()))

    df[&#34;Uncertainty_ELV&#34;] = df[[&#34;I78&#34;, &#34;Uncertainty_ELV&#34;]].groupby(&#34;I78&#34;).transform(lambda x: x.fillna(x.mean()))

    df.dEnergy = df.dEnergy.fillna(df.Energy * df.Uncertainty_E)
    df.dData = df.dData.fillna(df.Data * df.Uncertainty_D)
    df[&#34;dELV/HL&#34;] = df[&#34;dELV/HL&#34;].fillna(df[&#34;ELV/HL&#34;] * df[&#34;Uncertainty_ELV&#34;])

    df.Uncertainty_D = df.Uncertainty_D.replace(to_replace=np.inf, value=0)
    df.dData = df.dData.replace(to_replace=np.nan, value=0)
    df[&#34;dELV/HL&#34;] = df[&#34;dELV/HL&#34;].replace(to_replace=np.nan, value=0)
    df[&#34;ELV/HL&#34;] = df[&#34;ELV/HL&#34;].replace(to_replace=np.nan, value=0)

    df.fillna(value=0, inplace=True)

    df[&#34;Nucleus_Radius&#34;] = 1.25 * np.power(df[&#34;A&#34;], 1/3)
    df[&#34;Neutron_Nucleus_Radius_Ratio&#34;] = 0.8 / df[&#34;Nucleus_Radius&#34;]
    
    # Use this for ordering
    new_order = list(df.columns)[:35]
    new_order_2 = list(df.columns)[-6:]
    new_order.extend(new_order_2)
    nuclear_data_target = list(df.columns)[35:-6]
    new_order.extend(nuclear_data_target)

    df = df[new_order]

    df = df.drop(columns=[&#34;Uncertainty_D&#34;, &#34;Uncertainty_E&#34;, &#34;Uncertainty_ELV&#34;])

    logging.info(&#34;EXFOR CSV: Dropping RAW experimental datapoints...&#34;)
    df = df[~df.Reaction_Notation.str.contains(&#34;RAW&#34;)]

    df = df[~(df.Data &lt; 0)]

    logging.info(&#34;EXFOR CSV: Saving MF3 NaN Imputed RAW Free EXFOR CSV...&#34;)
    df.to_csv(os.path.join(heavy_path, &#34;EXFOR_&#34; + mode + &#34;_MF3_AME_no_RawNaN.csv&#34;), index=False)
    logging.info(&#34;Finished&#34;)
    return None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nucml.exfor" href="index.html">nucml.exfor</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="nucml.exfor.parsing_utilities.csv_creator" href="#nucml.exfor.parsing_utilities.csv_creator">csv_creator</a></code></li>
<li><code><a title="nucml.exfor.parsing_utilities.get_all" href="#nucml.exfor.parsing_utilities.get_all">get_all</a></code></li>
<li><code><a title="nucml.exfor.parsing_utilities.get_authors" href="#nucml.exfor.parsing_utilities.get_authors">get_authors</a></code></li>
<li><code><a title="nucml.exfor.parsing_utilities.get_c4_names" href="#nucml.exfor.parsing_utilities.get_c4_names">get_c4_names</a></code></li>
<li><code><a title="nucml.exfor.parsing_utilities.get_datapoints_per_experiment" href="#nucml.exfor.parsing_utilities.get_datapoints_per_experiment">get_datapoints_per_experiment</a></code></li>
<li><code><a title="nucml.exfor.parsing_utilities.get_dates" href="#nucml.exfor.parsing_utilities.get_dates">get_dates</a></code></li>
<li><code><a title="nucml.exfor.parsing_utilities.get_institutes" href="#nucml.exfor.parsing_utilities.get_institutes">get_institutes</a></code></li>
<li><code><a title="nucml.exfor.parsing_utilities.get_raw_datapoints" href="#nucml.exfor.parsing_utilities.get_raw_datapoints">get_raw_datapoints</a></code></li>
<li><code><a title="nucml.exfor.parsing_utilities.get_reaction_notations" href="#nucml.exfor.parsing_utilities.get_reaction_notations">get_reaction_notations</a></code></li>
<li><code><a title="nucml.exfor.parsing_utilities.get_references" href="#nucml.exfor.parsing_utilities.get_references">get_references</a></code></li>
<li><code><a title="nucml.exfor.parsing_utilities.get_titles" href="#nucml.exfor.parsing_utilities.get_titles">get_titles</a></code></li>
<li><code><a title="nucml.exfor.parsing_utilities.get_years" href="#nucml.exfor.parsing_utilities.get_years">get_years</a></code></li>
<li><code><a title="nucml.exfor.parsing_utilities.impute_original_exfor" href="#nucml.exfor.parsing_utilities.impute_original_exfor">impute_original_exfor</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>